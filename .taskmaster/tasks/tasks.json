{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "プロジェクト基盤のセットアップと開発環境構築",
        "description": "TypeScriptプロジェクトの初期化、必要な依存関係のインストール、開発環境の構築を行う",
        "details": "1. TypeScriptプロジェクトの初期化\n   - package.jsonの作成\n   - tsconfig.jsonの設定（strict: true、module: esnext、target: es2022）\n   - 必要な依存関係：typescript、@types/node、vite、vitest\n\n2. プロジェクト構造の作成\n   ```\n   src/\n     ├── core/           # コアロジック\n     ├── parsers/        # JSON/YAMLパーサー\n     ├── renderers/      # マインドマップレンダリング\n     ├── editors/        # エディタコンポーネント\n     ├── types/          # TypeScript型定義\n     └── utils/          # ユーティリティ関数\n   ```\n\n3. 開発ツールの設定\n   - ESLint、Prettier設定\n   - Git hooks（husky、lint-staged）\n   - VSCode設定ファイル",
        "testStrategy": "1. package.jsonのスクリプトが正しく動作することを確認\n2. TypeScriptのコンパイルが成功することを確認\n3. 開発サーバーが起動することを確認\n4. テストランナーが動作することを確認",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "TypeScriptプロジェクトの初期化とpnpm設定",
            "description": "pnpmを使用してTypeScriptプロジェクトを初期化し、package.jsonとtsconfig.jsonを適切に設定する",
            "dependencies": [],
            "details": "1. pnpm initでpackage.jsonを作成\n2. TypeScriptと基本的な型定義をインストール（typescript、@types/node）\n3. tsconfig.jsonの作成と設定：\n   - strict: true\n   - module: esnext\n   - target: es2022\n   - moduleResolution: bundler\n   - allowJs: false\n   - skipLibCheck: true\n4. package.jsonにscriptsを追加（build、dev、test）",
            "status": "done",
            "testStrategy": "1. pnpm installが正常に完了することを確認\n2. tscコマンドでTypeScriptのコンパイルが成功することを確認\n3. tsconfig.jsonの設定が正しく適用されることを確認"
          },
          {
            "id": 2,
            "title": "開発用依存関係のインストールと設定",
            "description": "Vite、Vitest、およびその他の開発ツールをインストールし、基本的な設定を行う",
            "dependencies": [
              "1.1"
            ],
            "details": "1. 開発用依存関係のインストール：\n   - vite（ビルドツール）\n   - vitest（テストフレームワーク）\n   - @vitest/ui（テストUI）\n2. vite.config.tsの作成：\n   - TypeScriptサポートの設定\n   - ソースマップの有効化\n   - 開発サーバーの設定\n3. vitest.config.tsの作成：\n   - テスト環境の設定\n   - カバレッジレポートの設定",
            "status": "done",
            "testStrategy": "1. pnpm devで開発サーバーが起動することを確認\n2. pnpm testでテストが実行されることを確認\n3. vite buildでビルドが成功することを確認"
          },
          {
            "id": 3,
            "title": "プロジェクトディレクトリ構造の作成",
            "description": "srcディレクトリ配下に必要なフォルダ構造を作成し、各モジュールの基本ファイルを配置する",
            "dependencies": [
              "1.1"
            ],
            "details": "1. ディレクトリ構造の作成：\n   - src/core/（コアロジック）\n   - src/parsers/（JSON/YAMLパーサー）\n   - src/renderers/（マインドマップレンダリング）\n   - src/editors/（エディタコンポーネント）\n   - src/types/（TypeScript型定義）\n   - src/utils/（ユーティリティ関数）\n2. 各ディレクトリにindex.tsを作成\n3. src/main.tsをエントリーポイントとして作成",
            "status": "done",
            "testStrategy": "1. すべてのディレクトリが正しく作成されていることを確認\n2. 各index.tsファイルが存在することを確認\n3. TypeScriptのパス解決が正しく機能することを確認"
          },
          {
            "id": 4,
            "title": "ESLintとPrettierの設定",
            "description": "コード品質とフォーマットを統一するためのESLintとPrettierを設定する",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "1. ESLint関連パッケージのインストール：\n   - eslint\n   - @typescript-eslint/parser\n   - @typescript-eslint/eslint-plugin\n   - eslint-config-prettier\n2. Prettierのインストール\n3. .eslintrc.jsonの作成（TypeScript推奨設定）\n4. .prettierrcの作成（コードフォーマット設定）\n5. .eslintignoreと.prettierignoreの作成\n6. package.jsonにlintスクリプトを追加",
            "status": "done",
            "testStrategy": "1. pnpm lintでESLintが正常に実行されることを確認\n2. pnpm formatでPrettierが正常に実行されることを確認\n3. ESLintとPrettierの設定が競合しないことを確認"
          },
          {
            "id": 5,
            "title": "Git hooksとVSCode設定の構成",
            "description": "コミット前の自動チェックとVSCodeの推奨設定を構成する",
            "dependencies": [
              "1.4"
            ],
            "details": "1. Git hooks関連パッケージのインストール：\n   - husky（Git hooks管理）\n   - lint-staged（ステージングファイルのlint）\n2. huskyの初期化：pnpm exec husky init\n3. pre-commitフックの設定（lint-staged実行）\n4. .lintstagedrc.jsonの作成\n5. .vscode/settings.jsonの作成：\n   - 保存時の自動フォーマット\n   - ESLint統合\n   - TypeScript設定\n6. .vscode/extensions.jsonで推奨拡張機能を定義",
            "status": "done",
            "testStrategy": "1. git commitでpre-commitフックが動作することを確認\n2. VSCodeで保存時に自動フォーマットが実行されることを確認\n3. lint-stagedが変更されたファイルのみを処理することを確認"
          }
        ]
      },
      {
        "id": 2,
        "title": "データモデルとスキーマ定義の実装",
        "description": "マインドマップのデータ構造を定義し、JSON/YAMLのスキーマバリデーションを実装する",
        "details": "1. TypeScript型定義の作成\n   ```typescript\n   interface MindMapNode {\n     id: string;\n     title: string;\n     description?: string;\n     children?: MindMapNode[];\n     metadata?: {\n       priority?: 'high' | 'medium' | 'low';\n       status?: string;\n       assignee?: string;\n       tags?: string[];\n       progress?: number;\n       dueDate?: string;\n     };\n     collapsed?: boolean;\n   }\n   ```\n\n2. JSON Schemaの定義\n   - ajvを使用したスキーマバリデーション\n   - エラーメッセージのローカライズ\n\n3. YAML/JSONパーサーの実装\n   - js-yamlを使用したYAML解析\n   - エラーハンドリングとリカバリー機能",
        "testStrategy": "1. 各種データ構造の単体テスト\n2. スキーマバリデーションのテスト（正常系・異常系）\n3. YAML/JSON相互変換のテスト\n4. 大規模データでのパフォーマンステスト",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "TypeScript型定義とインターフェースの実装",
            "description": "マインドマップノードの基本的なTypeScript型定義を作成し、拡張可能な構造を設計する",
            "dependencies": [],
            "details": "MindMapNodeインターフェースの完全な実装を行い、メタデータの拡張性を考慮した型定義を作成します。ジェネリック型を使用して柔軟な拡張を可能にし、型安全性を確保します。また、ユーティリティ型（DeepPartial、RequiredKeysなど）も定義します。",
            "status": "done",
            "testStrategy": "型定義の完全性テスト、型推論の正確性テスト、型ガードの動作確認テスト"
          },
          {
            "id": 2,
            "title": "JSON Schema定義とバリデーション実装",
            "description": "ajvライブラリを使用してJSON Schemaを定義し、バリデーション機能を実装する",
            "dependencies": [
              "2.1"
            ],
            "details": "MindMapNodeの構造に基づいたJSON Schemaを作成し、ajvを使用したバリデーターを実装します。カスタムキーワードの定義、エラーメッセージの日本語化、スキーマの動的生成機能も含みます。また、バリデーションエラーの詳細な情報を提供する仕組みを構築します。",
            "status": "done",
            "testStrategy": "正常系・異常系のバリデーションテスト、カスタムバリデーターのテスト、エラーメッセージの正確性テスト、境界値テスト"
          },
          {
            "id": 3,
            "title": "YAML/JSONパーサーとシリアライザーの実装",
            "description": "js-yamlを使用したYAML解析機能と、JSON/YAML間の相互変換機能を実装する",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "js-yamlライブラリを使用してYAMLの解析・生成機能を実装し、JSONとの相互変換を可能にします。エラーハンドリング、部分的な解析エラーからのリカバリー機能、フォーマット保持機能、コメント保持機能も実装します。大規模ファイルのストリーミング処理にも対応します。",
            "status": "done",
            "testStrategy": "各種フォーマットの解析テスト、エラーリカバリーテスト、相互変換の整合性テスト、大規模データのパフォーマンステスト"
          },
          {
            "id": 4,
            "title": "スキーマバージョニングとマイグレーション機能",
            "description": "スキーマのバージョン管理とデータマイグレーション機能を実装する",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "スキーマバージョンの管理システムを構築し、古いバージョンのデータを新しいスキーマに自動的に変換するマイグレーション機能を実装します。バージョン間の互換性チェック、段階的なマイグレーション、ロールバック機能も含みます。マイグレーション履歴の記録も行います。",
            "status": "done",
            "testStrategy": "バージョン間マイグレーションテスト、互換性チェックテスト、データ整合性テスト、ロールバックテスト"
          },
          {
            "id": 5,
            "title": "データ検証ユーティリティとヘルパー関数の実装",
            "description": "データ操作のための汎用的なユーティリティ関数とヘルパー関数を実装する",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "ノードID生成、ツリー構造の検証、循環参照チェック、データ正規化、デフォルト値の適用、データマージ機能などの汎用的なユーティリティ関数を実装します。また、デバッグ用のデータ可視化ヘルパーも提供します。",
            "status": "done",
            "testStrategy": "各ユーティリティ関数の単体テスト、エッジケースのテスト、パフォーマンステスト、統合テスト"
          }
        ]
      },
      {
        "id": 3,
        "title": "エディタコンポーネントの実装",
        "description": "JSON/YAML編集用のコードエディタを実装し、リアルタイム構文チェックと自動補完機能を提供する",
        "status": "in-progress",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "1. Monaco Editorの統合\n   - @monaco-editor/reactを使用\n   - JSON/YAML言語サポートの設定\n   - カスタムテーマの適用\n\n2. リアルタイムバリデーション\n   ```typescript\n   const validateContent = debounce((content: string) => {\n     try {\n       const parsed = parseYAML(content);\n       validateSchema(parsed);\n       updateMindMap(parsed);\n     } catch (error) {\n       showError(error);\n     }\n   }, 300);\n   ```\n\n3. エディタ機能の実装\n   - 構文ハイライト\n   - 自動インデント\n   - エラー箇所のマーキング\n   - インテリセンス（自動補完）",
        "testStrategy": "1. エディタの基本動作テスト\n2. 構文エラー検出のテスト\n3. デバウンス処理のテスト\n4. 大量テキスト編集時のパフォーマンステスト",
        "subtasks": [
          {
            "id": 1,
            "title": "Monaco Editorの基本統合",
            "description": "@monaco-editor/reactを使用してエディタコンポーネントを作成し、JSON/YAML言語サポートを設定する",
            "status": "done",
            "dependencies": [],
            "details": "1. @monaco-editor/reactパッケージのインストール\n2. MonacoEditorWrapperコンポーネントの作成\n3. JSON/YAML言語モードの設定\n4. エディタの基本オプション設定（フォントサイズ、テーマ、行番号表示など）\n5. エディタのサイズレスポンシブ対応",
            "testStrategy": "1. エディタコンポーネントのレンダリングテスト\n2. 言語モード切り替えのテスト\n3. エディタオプションの適用確認テスト"
          },
          {
            "id": 2,
            "title": "リアルタイムバリデーション機能",
            "description": "入力内容をリアルタイムで検証し、エラーをエディタ上に表示する機能を実装する",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "1. デバウンス処理付きバリデーション関数の実装\n2. JSON/YAMLパースエラーの検出\n3. スキーマバリデーションの統合\n4. Monaco Editorのマーカー機能を使用したエラー表示\n5. エラーメッセージのローカライズ対応",
            "testStrategy": "1. 構文エラー検出の精度テスト\n2. デバウンス処理のタイミングテスト\n3. エラーマーカーの表示位置テスト\n4. パフォーマンステスト（大量エラー時）"
          },
          {
            "id": 3,
            "title": "スキーマベース自動補完の実装",
            "description": "JSON Schemaの定義に基づいて、より高度な自動補完機能を実装する",
            "status": "deferred",
            "dependencies": [],
            "details": "1. スキーマ定義から補完候補を動的生成する機能の実装\n2. ネストされたプロパティの補完対応\n3. 必須フィールドと任意フィールドの区別表示\n4. データ型に応じた値の補完（enum値、デフォルト値など）\n5. カスタムスニペットとテンプレートの統合",
            "testStrategy": "1. スキーマベース補完の正確性テスト\n2. ネストレベルごとの補完候補テスト\n3. 大規模スキーマでのパフォーマンステスト\n4. 補完候補の優先順位テスト"
          },
          {
            "id": 4,
            "title": "完全な双方向同期の実装",
            "description": "エディタとマインドマップ間の完全な双方向同期を実現し、あらゆる操作が確実に反映されるようにする",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "1. 差分検出アルゴリズムの改善\n2. ノード位置情報の保持と復元\n3. アンドゥ/リドゥ操作の同期\n4. 同期競合の検出と解決メカニズム\n5. オフライン編集時の同期キューイング",
            "testStrategy": "1. 複雑な編集操作の同期テスト\n2. 同時編集時の競合解決テスト\n3. アンドゥ/リドゥの整合性テスト\n4. 大規模データでの同期パフォーマンステスト"
          },
          {
            "id": 5,
            "title": "エディタUI拡張機能の実装",
            "description": "エディタの使い勝手を向上させるための追加UI機能を実装する",
            "status": "pending",
            "dependencies": [
              1,
              3
            ],
            "details": "1. ミニマップ機能の追加\n2. 検索・置換機能の実装\n3. コードフォールディングの改善\n4. ブレッドクラムナビゲーションの実装\n5. エディタ設定パネルの追加（フォントサイズ、テーマ切り替えなど）",
            "testStrategy": "1. 各UI機能の動作テスト\n2. キーボードショートカットのテスト\n3. アクセシビリティテスト\n4. 異なる画面サイズでのUIテスト"
          }
        ]
      },
      {
        "id": 4,
        "title": "マインドマップレンダリングエンジンの実装",
        "description": "D3.jsを使用してインタラクティブなマインドマップの描画エンジンを実装する",
        "details": "1. D3.js力指向グラフの実装\n   ```typescript\n   const simulation = d3.forceSimulation(nodes)\n     .force('link', d3.forceLink(links).distance(100))\n     .force('charge', d3.forceManyBody().strength(-300))\n     .force('center', d3.forceCenter(width/2, height/2));\n   ```\n\n2. ノードレンダリング\n   - SVGベースの描画\n   - ノードの形状・色のカスタマイズ\n   - テキストの自動折り返し\n   - アイコン・バッジの表示\n\n3. インタラクション機能\n   - ズーム・パン（d3.zoom）\n   - ノードのドラッグ\n   - 折りたたみ・展開アニメーション\n   - ホバー時のツールチップ",
        "testStrategy": "1. レンダリング結果のスナップショットテスト\n2. インタラクション機能の統合テスト\n3. 100ノード以上でのパフォーマンステスト\n4. レスポンシブデザインのテスト",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "D3.js力指向グラフレイアウトエンジンの実装",
            "description": "D3.jsのforceSimulationを使用して、ノードとリンクの動的配置を管理するレイアウトエンジンを実装する",
            "dependencies": [],
            "details": "1. forceSimulationの初期化と設定\n   - ノード間の反発力（charge）の調整\n   - リンクの距離と強度の設定\n   - 中心力と境界制約の実装\n   - アルファ値の減衰率の最適化\n\n2. 動的レイアウト更新機能\n   - ノード追加・削除時の再計算\n   - リアルタイムレイアウト調整\n   - フォース値の動的変更API\n\n3. パフォーマンス最適化\n   - クアッドツリーの活用\n   - 計算頻度の調整\n   - 大規模グラフ対応",
            "status": "done",
            "testStrategy": "1. 各種フォース設定の動作確認テスト\n2. ノード配置の収束性テスト\n3. 1000ノード以上での計算速度測定\n4. レイアウトの安定性検証"
          },
          {
            "id": 2,
            "title": "SVGベースのノードレンダリングシステム",
            "description": "カスタマイズ可能なノード形状、スタイル、テキスト表示を含むSVGレンダリングシステムを構築する",
            "dependencies": [
              "4.1"
            ],
            "details": "1. ノード形状のレンダリング\n   - 矩形、円形、楕円形のサポート\n   - カスタムパスによる特殊形状\n   - グラデーション、影、境界線の適用\n\n2. テキストレンダリング機能\n   - 自動テキスト折り返しアルゴリズム\n   - フォントサイズの動的調整\n   - マルチライン対応\n   - テキストのトリミングと省略表示\n\n3. アイコン・バッジシステム\n   - SVGアイコンライブラリの統合\n   - ステータスバッジの表示\n   - プログレスインジケーター\n   - カスタムシンボルのサポート",
            "status": "done",
            "testStrategy": "1. 各種ノード形状の描画テスト\n2. テキスト折り返しの境界値テスト\n3. SVG要素のDOMスナップショットテスト\n4. レンダリング品質の視覚的検証"
          },
          {
            "id": 3,
            "title": "インタラクティブ操作コントローラーの実装",
            "description": "ズーム、パン、ドラッグなどのユーザーインタラクションを管理するコントローラーを開発する",
            "dependencies": [
              "4.2"
            ],
            "details": "1. ズーム・パン機能\n   - d3.zoomの実装と設定\n   - スムーズなズームトランジション\n   - ズーム範囲の制限設定\n   - ダブルクリックでのズームリセット\n\n2. ノードドラッグ機能\n   - ドラッグイベントハンドラー\n   - 物理シミュレーションとの統合\n   - ドラッグ中の視覚フィードバック\n   - マルチセレクションドラッグ\n\n3. タッチデバイス対応\n   - タッチイベントの処理\n   - ピンチズームの実装\n   - タッチドラッグの最適化",
            "status": "done",
            "testStrategy": "1. マウスイベントのシミュレーションテスト\n2. タッチイベントの動作確認\n3. ズーム範囲制限のテスト\n4. ドラッグ操作の精度測定"
          },
          {
            "id": 4,
            "title": "アニメーションエンジンの開発",
            "description": "ノードの展開・折りたたみ、トランジション効果を管理するアニメーションシステムを構築する",
            "dependencies": [
              "4.3"
            ],
            "details": "1. 展開・折りたたみアニメーション\n   - スムーズな展開トランジション\n   - 子ノードのフェードイン/アウト\n   - レイアウトの再計算と補間\n   - イージング関数の適用\n\n2. ホバーエフェクト\n   - ツールチップの表示アニメーション\n   - ノードのハイライト効果\n   - 関連リンクの強調表示\n   - プレビューカードの実装\n\n3. トランジション管理\n   - アニメーションキューの実装\n   - 並行アニメーションの制御\n   - パフォーマンス最適化\n   - requestAnimationFrameの活用",
            "status": "done",
            "testStrategy": "1. アニメーション完了タイミングのテスト\n2. 60FPS維持の性能テスト\n3. 複数アニメーション同時実行テスト\n4. メモリリークの検証"
          },
          {
            "id": 5,
            "title": "レンダリングパフォーマンス最適化システム",
            "description": "大規模マインドマップでも高速に動作する最適化システムを実装する",
            "dependencies": [
              "4.4"
            ],
            "details": "1. 仮想化レンダリング\n   - ビューポート内のノードのみ描画\n   - オフスクリーンノードの軽量化\n   - LOD（Level of Detail）システム\n   - プログレッシブレンダリング\n\n2. WebGLレンダラーの統合\n   - Three.jsとの連携オプション\n   - GPUアクセラレーション\n   - インスタンスレンダリング\n   - テクスチャアトラスの活用\n\n3. キャッシング戦略\n   - レンダリング結果のキャッシュ\n   - 計算結果のメモ化\n   - 差分レンダリングの実装\n   - Web Workerでの並列処理",
            "status": "done",
            "testStrategy": "1. 10000ノードでのFPS測定\n2. メモリ使用量の監視テスト\n3. 初期レンダリング時間の測定\n4. スクロール時のパフォーマンステスト"
          }
        ]
      },
      {
        "id": 5,
        "title": "リアルタイム同期システムの構築",
        "description": "エディタとマインドマップ間のリアルタイム同期機能を実装する",
        "details": "1. 状態管理の実装（Zustand）\n   ```typescript\n   interface AppState {\n     mindMapData: MindMapNode;\n     editorContent: string;\n     selectedNode: string | null;\n     updateMindMap: (data: MindMapNode) => void;\n     updateEditor: (content: string) => void;\n   }\n   ```\n\n2. 双方向同期の実装\n   - エディタ→マインドマップ：デバウンス付き更新\n   - マインドマップ→エディタ：ノードクリック時のハイライト\n   - 差分検出と最小限の再描画\n\n3. エラーリカバリー\n   - 一時的な構文エラー時の状態保持\n   - 最後の有効な状態へのロールバック",
        "testStrategy": "1. 同期タイミングのテスト\n2. 双方向データフローのテスト\n3. エラー発生時の状態保持テスト\n4. メモリリークの検証",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Zustand状態管理システムの実装",
            "description": "エディタとマインドマップの状態を管理するZustandストアを実装する",
            "dependencies": [],
            "details": "AppStateインターフェースに基づいたZustandストアの実装。mindMapData、editorContent、selectedNodeの状態管理と、updateMindMap、updateEditor、selectNode、clearSelectionなどのアクションを実装。状態の永続化（localStorage）とハイドレーション機能も含む。",
            "status": "done",
            "testStrategy": "ストアの初期化テスト、各アクションの動作確認テスト、状態の永続化と復元のテスト、複数コンポーネント間での状態共有テスト"
          },
          {
            "id": 2,
            "title": "エディタからマインドマップへの同期機能",
            "description": "エディタの変更をリアルタイムでマインドマップに反映する機能を実装する",
            "dependencies": [
              "5.1"
            ],
            "details": "エディタのonChangeイベントをデバウンス（300ms）で処理し、パース処理を実行。差分検出アルゴリズムを使用して変更箇所のみを更新。構文エラー時は最後の有効な状態を保持し、エラーインジケーターを表示。React.memoとuseMemoを使用した再レンダリング最適化。",
            "status": "done",
            "testStrategy": "デバウンス動作の検証、差分検出の正確性テスト、構文エラー時の状態保持テスト、パフォーマンステスト（1000ノード以上での動作確認）"
          },
          {
            "id": 3,
            "title": "マインドマップからエディタへの同期機能",
            "description": "マインドマップのノード操作をエディタに反映する機能を実装する",
            "dependencies": [
              "5.1"
            ],
            "details": "ノードクリック時のエディタ内該当箇所へのスクロールとハイライト機能。ノードのドラッグ＆ドロップによる構造変更のエディタ反映。ノード編集（インライン編集）の双方向バインディング。選択ノードの視覚的フィードバック（エディタ側でのハイライト表示）。",
            "status": "done",
            "testStrategy": "ノード選択時のスクロール位置の正確性テスト、ドラッグ＆ドロップ後のエディタコンテンツ整合性テスト、インライン編集の同期テスト、複数ノード選択時の動作テスト"
          },
          {
            "id": 4,
            "title": "エラーリカバリーとコンフリクト解決",
            "description": "同期エラー発生時のリカバリー機能とコンフリクト解決メカニズムを実装する",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "一時的な構文エラー時の状態保持とエラー表示。最後の有効な状態へのロールバック機能（Undo/Redo）。同時編集によるコンフリクト検出と解決UI。エラー発生時の自動リトライメカニズム（exponential backoff）。エラーログの収集と分析機能。",
            "status": "done",
            "testStrategy": "各種エラーパターンでのリカバリーテスト、ロールバック機能の動作確認、コンフリクト検出の精度テスト、リトライメカニズムのテスト"
          },
          {
            "id": 5,
            "title": "パフォーマンス最適化と監視",
            "description": "大規模データでの同期パフォーマンスを最適化し、監視機能を実装する",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "仮想スクロール（react-window）を使用した大規模ノードの効率的レンダリング。Web Workerを使用したパース処理のオフロード。RequestIdleCallbackを使用した非同期更新。パフォーマンスメトリクスの収集（同期遅延、メモリ使用量）。メモリリーク検出とクリーンアップ機能。",
            "status": "done",
            "testStrategy": "10000ノード以上での同期速度テスト、メモリリーク検出テスト、Web Worker通信のテスト、パフォーマンスメトリクスの正確性テスト"
          }
        ]
      },
      {
        "id": 6,
        "title": "ローカルストレージとファイル操作の実装",
        "description": "ローカル環境でのファイル読み書きとアプリケーション状態の永続化を実装する",
        "details": "1. File System Access APIの実装\n   ```typescript\n   async function openFile() {\n     const [fileHandle] = await window.showOpenFilePicker({\n       types: [{\n         description: 'Mind Map Files',\n         accept: {\n           'application/json': ['.json'],\n           'text/yaml': ['.yaml', '.yml']\n         }\n       }]\n     });\n     return fileHandle;\n   }\n   ```\n\n2. ローカルストレージ管理\n   - 最近使用したファイルの記録\n   - アプリケーション設定の保存\n   - 自動保存の実装\n\n3. ファイル監視機能\n   - 外部変更の検出\n   - リロード確認ダイアログ",
        "testStrategy": "1. ファイル読み書きの単体テスト\n2. ローカルストレージのCRUDテスト\n3. ファイル形式変換のテスト\n4. 権限エラーハンドリングのテスト",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "File System Access APIの実装とファイルハンドリング",
            "description": "ブラウザのFile System Access APIを使用してファイルの読み書き機能を実装する",
            "dependencies": [],
            "details": "1. showOpenFilePicker/showSaveFilePickerの実装\n2. FileHandleの管理とキャッシュ\n3. ファイル読み込み時のエラーハンドリング\n4. ファイル書き込み時の権限確認\n5. 対応ファイル形式（.json, .yaml, .yml）の処理",
            "status": "pending",
            "testStrategy": "1. モックを使用したFile System APIのテスト\n2. 各種ファイル形式の読み込みテスト\n3. 権限エラー時の挙動テスト"
          },
          {
            "id": 2,
            "title": "ローカルストレージ管理システムの構築",
            "description": "アプリケーション設定と最近使用したファイルの情報をローカルストレージで管理する",
            "dependencies": [
              "6.1"
            ],
            "details": "1. LocalStorageラッパークラスの実装\n2. 最近使用したファイル一覧の管理（最大10件）\n3. アプリケーション設定の保存・読み込み\n4. データ容量制限の監視\n5. 破損データの検出と復旧処理",
            "status": "pending",
            "testStrategy": "1. LocalStorage APIのモックテスト\n2. 容量制限時の動作テスト\n3. データ破損時の復旧テスト"
          },
          {
            "id": 3,
            "title": "自動保存機能の実装",
            "description": "ユーザーの変更を検知して定期的に自動保存する機能を実装する",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "1. 変更検知システムの実装（debounce付き）\n2. 自動保存インターバルの設定（デフォルト30秒）\n3. 保存状態インジケーターの実装\n4. 保存失敗時のリトライ機構\n5. 未保存変更の警告ダイアログ",
            "status": "pending",
            "testStrategy": "1. 変更検知の精度テスト\n2. 自動保存タイミングのテスト\n3. 保存失敗時のリトライテスト"
          },
          {
            "id": 4,
            "title": "ファイル監視システムの実装",
            "description": "外部でのファイル変更を検知してユーザーに通知する機能を実装する",
            "dependencies": [
              "6.1"
            ],
            "details": "1. ファイルの最終更新時刻の監視\n2. ポーリング間隔の最適化（1-5秒）\n3. 変更検知時の差分比較\n4. リロード確認ダイアログの実装\n5. マージ競合の検出と解決UI",
            "status": "pending",
            "testStrategy": "1. ファイル変更検知の精度テスト\n2. 同時編集シナリオのテスト\n3. マージ競合解決のテスト"
          },
          {
            "id": 5,
            "title": "ファイル操作の状態管理とエラーハンドリング",
            "description": "ファイル操作全体の状態管理とエラー処理を統合的に実装する",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "1. ファイル操作状態のグローバル管理\n2. エラーメッセージのローカライズ\n3. リトライ可能なエラーの自動リトライ\n4. ユーザーへの通知システム（トースト/モーダル）\n5. 操作履歴とアンドゥ機能の連携",
            "status": "pending",
            "testStrategy": "1. 各種エラーシナリオのテスト\n2. 状態遷移の整合性テスト\n3. エラーリカバリーのテスト"
          }
        ]
      },
      {
        "id": 7,
        "title": "UIテーマとカスタマイズ機能の実装",
        "description": "シンプルなダークモード対応を実装し、システム設定に連動したテーマ切り替え機能を提供する",
        "status": "done",
        "dependencies": [
          5
        ],
        "priority": "medium",
        "details": "1. CSS変数ベースのテーマシステム\n   ```css\n   :root {\n     --bg-primary: #ffffff;\n     --text-primary: #333333;\n     --node-bg: #f0f0f0;\n     --link-color: #666666;\n   }\n   \n   [data-theme=\"dark\"] {\n     --bg-primary: #1a1a1a;\n     --text-primary: #e0e0e0;\n     --node-bg: #2a2a2a;\n     --link-color: #888888;\n   }\n   ```\n\n2. テーマ切り替え機能\n   - システム設定の自動検出（prefers-color-scheme）\n   - 手動切り替えトグルボタン\n   - localStorageによるテーマ設定の永続化",
        "testStrategy": "1. テーマ切り替えの動作テスト\n2. システム設定との連動確認テスト\n3. localStorage保存・読み込みテスト\n4. 基本的なアクセシビリティテスト（コントラスト比）",
        "subtasks": [
          {
            "id": 1,
            "title": "CSS変数ベースのテーマシステムの実装",
            "description": "CSS変数を使用したライトモードとダークモードの基本テーマを定義する",
            "status": "done",
            "dependencies": [],
            "details": "CSS変数を使用してテーマシステムの基盤を実装します。色のデザイントークンを定義し、:root と [data-theme=\"dark\"] セレクタを使用してライト/ダークテーマの切り替えを可能にします。マインドマップの各要素（背景、テキスト、ノード、リンク）に適用される基本的な色変数を定義します。",
            "testStrategy": "CSS変数の適用確認、テーマ切り替え時のスタイル変更テスト、主要ブラウザでの互換性テスト"
          },
          {
            "id": 2,
            "title": "テーマ切り替え機能とシステム設定連携",
            "description": "ユーザーのシステム設定を検出して自動的にテーマを適用し、手動切り替えUIを実装する",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "prefers-color-scheme メディアクエリを使用してユーザーのシステム設定を検出し、自動的に適切なテーマを適用します。シンプルなトグルボタンを実装し、ユーザーが手動でテーマを切り替えられるようにします。選択したテーマをlocalStorageに保存して永続化し、次回訪問時に適用します。\n<info added on 2025-08-14T19:28:21.091Z>\n実装完了の詳細：\n\n## ThemeToggleコンポーネントの実装内容\n\n### 1. システム設定の自動検出機能\n- `getSystemTheme()`関数でシステムのテーマ設定を検出\n- `window.matchMedia('(prefers-color-scheme: dark)')`を使用してダークモード設定を判定\n- システム設定が変更された際のリアルタイム監視機能も実装\n\n### 2. 3モード切り替えUI\n- ライトモード（☀️）、ダークモード（🌙）、オートモード（🔄）の3つのモードに対応\n- 絵文字アイコンを使用した直感的なUI設計\n- FileToolbarコンポーネントに統合され、常にアクセス可能な位置に配置\n- クリックするたびに「ライト→ダーク→オート→ライト」の順でモードが循環\n\n### 3. localStorage永続化の実装\n- テーマ選択を`localStorage.setItem('theme', theme)`で保存\n- ページ読み込み時に`localStorage.getItem('theme')`で復元\n- オートモード選択時はシステム設定に追従し、その状態も保存\n\n### 動作確認完了項目\n- システム設定変更時の自動切り替え\n- 手動切り替え時の即座の反映\n- ページリロード後の設定保持\n- 各テーマのCSS変数が正しく適用されていることを確認\n\n全ての実装要件が満たされ、正常に動作することを確認済み。\n</info added on 2025-08-14T19:28:21.091Z>",
            "testStrategy": "システム設定の自動検出テスト、手動切り替えの動作確認、localStorage保存・読み込みテスト"
          },
          {
            "id": 3,
            "title": "基本的なアクセシビリティ対応",
            "description": "ライト/ダークテーマのコントラスト比を確保し、基本的なアクセシビリティ要件を満たす",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "WCAG 2.1ガイドラインに準拠した最小限のコントラスト比（通常テキスト4.5:1、大きいテキスト3:1）を確保します。特にダークモードでの可読性を重視し、適切な色の組み合わせを選定します。また、テーマ切り替えボタンのアクセシビリティ（ARIAラベル、キーボード操作）も実装します。\n<info added on 2025-08-14T19:32:23.398Z>\nアクセシビリティ対応完了:\n\n## 実装したアクセシビリティ機能\n\n### 1. WCAG 2.1準拠のコントラスト比確保 ✅\n- ダークモードでの背景色とテキストのコントラスト比を改善\n- テーマトグルボタンの視認性を向上（#374151背景に#f9fafb文字）\n- ホバー時とフォーカス時の色のコントラストを最適化\n\n### 2. キーボードナビゲーション強化 ✅\n- focus-visibleでの明確なフォーカスインジケーター\n- アウトライン + ボックスシャドウの二重表示\n- フォーカス時の追加ボーダー表示（::after疑似要素）\n\n### 3. ARIAラベルとスクリーンリーダー対応 ✅\n- aria-label属性で現在のテーマ状態を明示\n- title属性でツールチップ表示\n- 状態変更時の適切な読み上げ対応\n\n### 4. ハイコントラストモード対応 ✅\n- prefers-contrast: high メディアクエリ対応\n- ボーダー幅とコントラストの強化\n- アイコンのコントラスト向上（filter: contrast(1.5)）\n\n### 5. 動作軽減設定対応 ✅\n- prefers-reduced-motion: reduce対応済み\n- アニメーションの無効化機能\n\n全てのWCAG 2.1 AA基準に準拠したアクセシビリティ機能を実装完了。\n</info added on 2025-08-14T19:32:23.398Z>",
            "testStrategy": "コントラスト比の測定、キーボードナビゲーションテスト、スクリーンリーダーでの基本動作確認"
          }
        ]
      },
      {
        "id": 8,
        "title": "高度な機能群の実装（タグ、進捗管理）",
        "description": "タグシステムと進捗管理機能を実装する",
        "status": "pending",
        "dependencies": [
          5,
          6
        ],
        "priority": "medium",
        "details": "1. タグ・ラベルシステム\n   ```typescript\n   interface TagSystem {\n     tags: Map<string, TagDefinition>;\n     addTag(node: string, tag: string): void;\n     filterByTag(tag: string): MindMapNode[];\n     getTagStats(): TagStatistics;\n   }\n   ```\n\n2. 進捗管理機能\n   - ノード単位の進捗率設定\n   - 親ノードの自動集計\n   - 進捗ダッシュボード\n   - ガントチャート表示",
        "testStrategy": "1. タグフィルタリングのテスト\n2. 進捗計算ロジックのテスト\n3. 機能間の統合テスト",
        "subtasks": [
          {
            "id": 1,
            "title": "タグシステムの基本実装",
            "description": "タグの定義、追加、削除、フィルタリングなどの基本的なタグ管理機能を実装する",
            "status": "pending",
            "dependencies": [],
            "details": "TagDefinitionインターフェースの定義、タグの追加・削除メソッド、タグによるノードフィルタリング機能、タグの統計情報取得機能を実装。タグの色分けやアイコン設定、タグの階層構造サポート、タグのバリデーション機能も含む",
            "testStrategy": "タグの追加・削除の単体テスト、フィルタリング機能の正確性テスト、複数タグの組み合わせフィルタリングテスト、タグ統計の計算テスト"
          },
          {
            "id": 2,
            "title": "進捗管理システムの実装",
            "description": "ノード単位の進捗率設定と親ノードへの自動集計機能を実装する",
            "status": "pending",
            "dependencies": [],
            "details": "ノードごとの進捗率プロパティの追加、子ノードの進捗から親ノードの進捗を自動計算するロジック、進捗の可視化用データ構造、進捗変更時のイベント通知システム、進捗の履歴管理機能を実装",
            "testStrategy": "進捗計算ロジックの単体テスト、階層構造での進捗集計テスト、循環参照時の処理テスト、大規模データでのパフォーマンステスト"
          },
          {
            "id": 3,
            "title": "進捗ダッシュボードとガントチャートの実装",
            "description": "進捗管理の可視化機能としてダッシュボードとガントチャート表示を実装する",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "進捗ダッシュボードコンポーネントの作成、全体進捗の集計表示、カテゴリ別進捗表示、ガントチャート用のデータ変換処理、タイムライン表示機能、マイルストーン管理、クリティカルパスの可視化を実装",
            "testStrategy": "ダッシュボードのレンダリングテスト、ガントチャートのデータ変換テスト、大規模データでの描画パフォーマンステスト、インタラクティブ機能のテスト"
          }
        ]
      },
      {
        "id": 10,
        "title": "VSCode拡張対応とパフォーマンス最適化",
        "description": "VSCode拡張として動作するための準備とアプリケーション全体のパフォーマンス最適化を行う",
        "details": "1. VSCode拡張アーキテクチャ\n   ```typescript\n   // コアロジックの分離\n   export class MindMapCore {\n     // プラットフォーム非依存のロジック\n   }\n   \n   // VSCode拡張アダプター\n   export class VSCodeAdapter {\n     constructor(private core: MindMapCore) {}\n     // VSCode API統合\n   }\n   ```\n\n2. パフォーマンス最適化\n   - 仮想スクロール実装（大量ノード対応）\n   - Web Workerでの重い処理\n   - React.memoとuseMemoの活用\n   - バンドルサイズの最適化\n\n3. プログレッシブ機能\n   - 段階的な機能読み込み\n   - オフライン対応（Service Worker）\n   - インストール可能なPWA",
        "testStrategy": "1. VSCode拡張としての動作確認\n2. 1000ノード以上でのパフォーマンステスト\n3. メモリ使用量のプロファイリング\n4. バンドルサイズの検証",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          7,
          8
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "コアロジックの分離とプラットフォーム非依存アーキテクチャの設計",
            "description": "VSCode拡張とWebアプリケーションで共有可能なコアロジックを分離し、プラットフォーム非依存のアーキテクチャを構築する",
            "dependencies": [],
            "details": "MindMapCoreクラスの実装：マインドマップのデータ構造管理、ノード操作API、イベントシステム、状態管理ロジックをプラットフォーム固有の実装から完全に分離。インターフェースベースの設計でアダプターパターンを適用し、VSCode拡張とWebアプリケーションの両方から利用可能な構造を実現\n<info added on 2025-08-14T19:46:03.742Z>\n現状の問題：現在のMindmapCoreクラスは描画専用の実装となっており、真のコアロジック（データ管理、ノード操作、イベントシステム、状態管理）がプラットフォーム依存の描画ロジックと混在している。これにより、VSCode拡張とWebアプリケーション間でのコード共有が困難になっている。\n\nリファクタリング戦略：テストファースト・リファクタリングアプローチを採用し、既存の動作を保証しながら段階的にアーキテクチャを改善する。実装を2つのフェーズに分割し、各フェーズを独立したサブタスクとして管理する。\n\nPhase 1 - テスト構築フェーズ：\n1. MindmapCore統合テスト作成：現在の描画機能を含む全体的な振る舞いをテストでカバー\n2. コアロジック振る舞いテスト作成：データ管理、ノード操作、イベントシステム、状態管理の期待される動作を定義\n3. プラットフォーム統合テスト強化：Web環境とVSCode環境での動作差異を検証するテストを追加\n4. E2Eテスト拡充とカバレッジ確認：ユーザーシナリオに基づいたエンドツーエンドテストの網羅性を向上\n\nPhase 2 - 段階的リファクタリングフェーズ：\n5. ICoreLogicインターフェース定義：データ管理、ノード操作、イベントシステム、状態管理のための抽象インターフェースを設計\n6. MindmapCoreLogicクラス新規作成：ICoreLogicを実装し、プラットフォーム非依存のコアロジックを集約\n7. 既存コードとの段階的統合：テストを通過させながら、既存のMindmapCoreから新しいMindmapCoreLogicへ責務を移行\n8. MindmapCore→MindmapRenderer移行：最終的にMindmapCoreを描画専用のMindmapRendererクラスにリネームし、責務を明確化\n\n実装の複雑さと影響範囲：このリファクタリングは全体のアーキテクチャに影響を与えるため、各サブタスクは慎重に実行し、常にテストが通過することを確認しながら進める必要がある。\n</info added on 2025-08-14T19:46:03.742Z>\n<info added on 2025-08-15T01:47:40.870Z>\nタスク10.1「コアロジックの分離とプラットフォーム非依存アーキテクチャの設計」完了\n\n実装内容：\n\n1. ICoreLogicインターフェース設計\n- データ管理、ノードCRUD操作、ツリー構造操作の抽象インターフェースを定義\n- Undo/Redo機能、イベントシステム、検索・フィルタリング機能を含む包括的な設計\n- プラットフォーム非依存の完全な仕様を策定\n\n2. MindmapCoreLogicクラス実装\n- ICoreLogicインターフェースの完全実装\n- コマンドパターンによるUndo/Redo機能\n- 効率的なイベントシステムとインデックス管理\n- バッチ更新とパフォーマンス最適化機能\n- 全33項目のTDDテストが通過\n\n3. MindmapRendererクラス分離\n- 既存のMindmapCoreから描画専用ロジックを分離\n- D3.js描画機能を純粋化し、データ管理責務を除去\n- プラットフォーム非依存の描画エンジンとして再構築\n\n4. 統合MindmapCoreクラス\n- MindmapCoreLogicとMindmapRendererを統合\n- 従来APIとの完全な後方互換性を維持\n- 自動的なデータ同期とイベント連携\n\n5. テスト・品質確認\n- 全84個のテストケースが通過\n- TypeScriptビルドが成功\n- 既存コンポーネントとの統合性を保持\n\nアーキテクチャ改善：\nBefore（問題のあった構造）：MindmapCore（描画＋データ管理が混在）にD3.js描画ロジック、データ管理ロジック、状態管理ロジック、イベントシステムが混在\n\nAfter（責務分離された新構造）：MindmapCore（統合ファサード）がMindmapCoreLogic（プラットフォーム非依存：データ管理、状態管理、Undo/Redo、イベントシステム、検索・フィルタリング）とMindmapRenderer（描画専用：D3.js描画、レイアウト計算、SVG操作、ビュー操作）を統合する構造に改善\n\nこれによりVSCode拡張とWebアプリケーション間での真のコード共有が可能になった\n</info added on 2025-08-15T01:47:40.870Z>",
            "status": "done",
            "testStrategy": "コアロジックの単体テスト、プラットフォーム非依存性の確認テスト、APIインターフェースの整合性テスト"
          },
          {
            "id": 2,
            "title": "VSCode拡張アダプターとAPI統合の実装",
            "description": "VSCode Extension APIと統合するアダプター層を実装し、エディタ機能との連携を確立する",
            "dependencies": [
              "10.1"
            ],
            "details": "VSCodeAdapterクラスの実装：VSCode APIとの統合（TextDocument、TreeDataProvider、WebviewPanel）、コマンドパレット統合、エディタとの双方向通信、ファイルシステムアクセス、拡張機能の設定管理。manifest（package.json）の構成とアクティベーションイベントの定義",
            "status": "in-progress",
            "testStrategy": "VSCode Extension Testフレームワークを使用した統合テスト、モックを使用したAPI呼び出しテスト、拡張機能のアクティベーションテスト"
          },
          {
            "id": 6,
            "title": "VSCode拡張用ノード詳細パネルコンポーネントの実装",
            "description": "VSCode拡張のMindmapViewerに、Web版のNodeDetailsPanelと同様のノード詳細表示パネルを実装する",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 7,
            "title": "VSCode拡張用ノード編集機能（詳細パネル内）の実装",
            "description": "詳細パネル内でノード情報（タイトル、説明、カスタムフィールドなど）を編集できる機能を実装する",
            "details": "",
            "status": "pending",
            "dependencies": [
              "10.6"
            ],
            "parentTaskId": 10
          },
          {
            "id": 8,
            "title": "VSCode拡張用ノード追加機能（子・兄弟追加）の実装",
            "description": "選択ノードに対して「子を追加」「兄弟を追加」ボタンを表示し、新しいノードを追加する機能を実装する",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 9,
            "title": "VSCode拡張用ノード削除機能の実装",
            "description": "選択ノードを削除する機能と確認ダイアログを実装する",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 10
          },
          {
            "id": 10,
            "title": "VSCode拡張用ツールバーUIの実装",
            "description": "ズーム、レイアウト切り替え、ノード操作ボタンなどのツールバーUIを実装する",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 10
          }
        ]
      },
      {
        "id": 11,
        "title": "プロジェクトセットアップとMCP基盤構築",
        "description": "MCPサーバーの基本構造を構築し、マインドマップ操作のための基盤を整備する",
        "details": "1. TypeScriptプロジェクトの初期化\n2. MCPサーバーの基本構造を実装\n3. 必要な依存関係のインストール（@modelcontextprotocol/sdk、zod、winston等）\n4. 基本的なツール定義インターフェースの作成\n5. エラーハンドリングとロギングの基盤を実装\n\n```typescript\n// server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\n\nconst server = new Server({\n  name: 'mindmap-mcp-server',\n  version: '1.0.0'\n});\n\n// ツール登録\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: [\n    // マインドマップ操作ツールを定義\n  ]\n}));\n```",
        "testStrategy": "1. MCPサーバーの起動確認テスト\n2. 基本的なツール登録の動作確認\n3. エラーハンドリングのユニットテスト\n4. ロギング機能の動作確認",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "TypeScriptプロジェクトの初期化と基本設定",
            "description": "TypeScriptプロジェクトを初期化し、MCPサーバー開発に必要な基本設定を行う",
            "dependencies": [],
            "details": "package.jsonの作成、tsconfig.jsonの設定（strict: true、module: esnext、target: es2022、esModuleInterop: true）、.gitignoreの作成、プロジェクトディレクトリ構造の作成（src/、dist/、tests/）、npm scriptsの設定（build、dev、test、lint）",
            "status": "done",
            "testStrategy": "npm installが正常に完了すること、tscコマンドでコンパイルエラーが発生しないこと、プロジェクト構造が正しく作成されていることを確認"
          },
          {
            "id": 2,
            "title": "MCP SDK依存関係のインストールと設定",
            "description": "@modelcontextprotocol/sdkとその関連パッケージをインストールし、必要な設定を行う",
            "dependencies": [
              "11.1"
            ],
            "details": "@modelcontextprotocol/sdk、@modelcontextprotocol/sdk/server、@modelcontextprotocol/sdk/server/stdioのインストール、zod、winston、dotenvなどの必要なライブラリのインストール、型定義ファイル（@types/*）のインストール、package.jsonのtype: moduleの設定確認",
            "status": "done",
            "testStrategy": "すべての依存関係が正しくインストールされていること、importステートメントが正常に機能すること、型チェックが正常に動作することを確認"
          },
          {
            "id": 3,
            "title": "MCPサーバーの基本構造実装",
            "description": "MCPサーバーのメインエントリーポイントとなるserver.tsを実装し、基本的なサーバー構造を構築する",
            "dependencies": [
              "11.2"
            ],
            "details": "server.tsの作成、Serverインスタンスの初期化（name: 'mindmap-mcp-server'、version: '1.0.0'）、StdioServerTransportの設定、基本的なリクエストハンドラーの実装（ListToolsRequestSchema）、サーバー起動処理の実装、package.jsonにbinフィールドを追加してCLIとして実行可能にする",
            "status": "done",
            "testStrategy": "MCPサーバーが正常に起動すること、標準入出力での通信が可能なこと、ListToolsリクエストに応答できること、エラーなくプロセスが終了すること"
          },
          {
            "id": 4,
            "title": "ツール定義インターフェースとスキーマの作成",
            "description": "マインドマップ操作用のツール定義インターフェースとZodスキーマを作成する",
            "dependencies": [
              "11.3"
            ],
            "details": "src/types/tools.tsの作成、マインドマップ操作ツールのインターフェース定義（create、read、update、delete、search、export）、各ツールのZodスキーマ定義、入力パラメータと出力形式の型定義、ツール登録用のヘルパー関数の実装",
            "status": "done",
            "testStrategy": "すべてのツール定義が正しくコンパイルされること、Zodスキーマのバリデーションが正常に動作すること、型の整合性が保たれていることを確認"
          },
          {
            "id": 5,
            "title": "エラーハンドリングとロギング基盤の実装",
            "description": "堅牢なエラーハンドリング機構とWinstonを使用したロギングシステムを実装する",
            "dependencies": [
              "11.4"
            ],
            "details": "src/utils/logger.tsの作成（Winstonロガーの設定）、src/utils/errors.tsの作成（カスタムエラークラスの定義）、グローバルエラーハンドラーの実装、非同期エラーのキャッチ機構、ログレベルの設定（debug、info、warn、error）、ログファイルのローテーション設定",
            "status": "done",
            "testStrategy": "各種エラーが適切にキャッチされログに記録されること、ログファイルが正しく生成されること、エラー時にサーバーがクラッシュしないこと、ログレベルが正しく機能することを確認"
          }
        ]
      },
      {
        "id": 12,
        "title": "マインドマップスキーマ定義と検証システム",
        "description": "マインドマップのJSONスキーマを定義し、データ構造の検証システムを実装する",
        "details": "1. Zodを使用したマインドマップスキーマの定義\n2. ノード構造（ID、タイトル、説明、タイプ、カスタム属性）の定義\n3. スキーマバリデーション関数の実装\n4. カスタムスキーマのサポート機能\n5. スキーマ情報を返すMCPツールの実装\n\n```typescript\nimport { z } from 'zod';\n\nconst NodeSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  description: z.string().optional(),\n  type: z.string(),\n  children: z.array(z.lazy(() => NodeSchema)).optional(),\n  customAttributes: z.record(z.any()).optional(),\n  metadata: z.object({\n    createdAt: z.string().datetime(),\n    updatedAt: z.string().datetime(),\n    version: z.number()\n  })\n});\n\nconst MindmapSchema = z.object({\n  version: z.string(),\n  root: NodeSchema,\n  metadata: z.object({\n    lastModified: z.string().datetime(),\n    author: z.string().optional()\n  })\n});\n```",
        "testStrategy": "1. 有効なマインドマップデータの検証テスト\n2. 無効なデータに対するエラー検出テスト\n3. カスタムスキーマの適用テスト\n4. スキーマ情報取得ツールの統合テスト",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Zodスキーマの基本定義と型構造の実装",
            "description": "マインドマップの基本的なデータ構造をZodで定義し、TypeScript型を生成する",
            "dependencies": [],
            "details": "NodeSchemaとMindmapSchemaの基本構造を定義し、再帰的な子ノード構造をサポート。メタデータフィールド（createdAt、updatedAt、version）を含む完全な型定義を実装。z.infer<>を使用してTypeScript型を自動生成し、型の再利用性を確保",
            "status": "pending",
            "testStrategy": "基本的なノード構造の検証テスト、再帰的な子ノードの検証テスト、メタデータフィールドの必須項目チェック"
          },
          {
            "id": 2,
            "title": "カスタム属性とスキーマ拡張システムの実装",
            "description": "ユーザー定義のカスタム属性をサポートし、スキーマを動的に拡張できる仕組みを構築",
            "dependencies": [
              "12.1"
            ],
            "details": "customAttributesフィールドにz.record()を使用し、任意のキー・バリューペアを許可。スキーマ継承システムを実装し、ベーススキーマを拡張してドメイン固有のスキーマを作成可能に。スキーママージ機能とコンフリクト解決ロジックを含む",
            "status": "pending",
            "testStrategy": "カスタム属性の追加・更新テスト、スキーマ継承の動作確認、互換性のないスキーママージのエラーハンドリングテスト"
          },
          {
            "id": 3,
            "title": "バリデーション関数とエラーハンドリングの実装",
            "description": "Zodスキーマを使用した包括的なバリデーション関数とユーザーフレンドリーなエラーメッセージシステムを構築",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "validateMindmap()関数でスキーマ全体の検証を実行。エラーメッセージの日本語ローカライズ対応。パスベースのエラー位置特定機能（例：root.children[2].metadata.version）。部分検証とストリクトモードのオプション提供",
            "status": "pending",
            "testStrategy": "有効なデータの成功ケース、各種バリデーションエラーの検出、エラーメッセージの正確性確認、パフォーマンステスト（1000ノード以上）"
          },
          {
            "id": 4,
            "title": "スキーマバージョニングとマイグレーションシステム",
            "description": "スキーマのバージョン管理と自動マイグレーション機能を実装",
            "dependencies": [
              "12.3"
            ],
            "details": "バージョンフィールドを使用したスキーマバージョン管理。古いバージョンから新しいバージョンへの自動変換ルール定義。後方互換性の維持とdeprecationの警告機能。マイグレーション履歴の記録とロールバック機能",
            "status": "pending",
            "testStrategy": "バージョン間のマイグレーションテスト、後方互換性の確認、マイグレーションエラーのハンドリング、大規模データのマイグレーションパフォーマンス"
          },
          {
            "id": 5,
            "title": "MCPツール実装とスキーマ情報API",
            "description": "スキーマ情報を返すMCPツールを実装し、外部システムとの連携を可能にする",
            "dependencies": [
              "12.3",
              "12.4"
            ],
            "details": "getSchemaInfo()ツールでスキーマ定義をJSON形式で返却。validateMindmapData()ツールでリアルタイムバリデーション。getAvailableNodeTypes()でサポートされるノードタイプ一覧を提供。スキーマドキュメントの自動生成機能を含む",
            "status": "pending",
            "testStrategy": "MCPツールのレスポンス形式テスト、大規模スキーマ情報の取得パフォーマンス、エラーケースのハンドリング確認、統合テスト"
          }
        ]
      },
      {
        "id": 13,
        "title": "マインドマップ読み取り機能の実装",
        "description": "マインドマップファイルの読み取りとデータ取得機能を実装する",
        "details": "1. ファイル読み取り機能の実装\n2. JSON解析とスキーマ検証の統合\n3. 特定ノード検索機能の実装\n4. メタデータ取得機能の実装\n5. MCPツールとしての公開\n\n```typescript\nconst readMindmapTool = {\n  name: 'read_mindmap',\n  description: 'マインドマップデータを読み取る',\n  inputSchema: z.object({\n    filePath: z.string(),\n    nodeId: z.string().optional()\n  }),\n  handler: async ({ filePath, nodeId }) => {\n    const data = await fs.readFile(filePath, 'utf-8');\n    const mindmap = MindmapSchema.parse(JSON.parse(data));\n    \n    if (nodeId) {\n      return findNodeById(mindmap.root, nodeId);\n    }\n    return mindmap;\n  }\n};\n```",
        "testStrategy": "1. 正常なファイル読み取りテスト\n2. 不正なファイルパスのエラーハンドリングテスト\n3. ノード検索機能のテスト\n4. 大規模マインドマップのパフォーマンステスト",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "ファイル読み取り基盤機能の実装",
            "description": "マインドマップファイルを安全に読み取るための基盤機能を実装する",
            "dependencies": [],
            "details": "Node.jsのfsモジュールを使用してファイルを非同期で読み取る機能を実装。ファイルパスの検証、ファイル存在確認、読み取り権限チェック、エラーハンドリング（ファイルが存在しない、権限がない、破損している等）を含む。UTF-8エンコーディングでの読み取りを保証し、大きなファイルに対応するためのストリーミング読み取りオプションも検討する。",
            "status": "pending",
            "testStrategy": "正常なファイル読み取りテスト、存在しないファイルのエラーテスト、権限エラーテスト、空ファイルの処理テスト、大容量ファイル（10MB以上）の読み取りパフォーマンステスト"
          },
          {
            "id": 2,
            "title": "JSON解析とスキーマ検証の統合",
            "description": "読み取ったJSONデータを解析し、定義済みのMindmapSchemaで検証する機能を実装する",
            "dependencies": [
              "13.1"
            ],
            "details": "JSON.parseでデータを解析し、zodライブラリのMindmapSchemaを使用して構造を検証。不正なJSON形式、スキーマ違反、循環参照の検出を実装。バリデーションエラーの詳細なメッセージを生成し、どのフィールドが問題なのかを明確に示す。パーシャルバリデーションモードも実装し、一部のフィールドが欠落していても動作するようにする。",
            "status": "pending",
            "testStrategy": "正常なマインドマップデータの検証テスト、不正なJSON形式のエラーテスト、スキーマ違反の各種パターンテスト、循環参照データの検出テスト、パーシャルデータの検証テスト"
          },
          {
            "id": 3,
            "title": "特定ノード検索機能の実装",
            "description": "マインドマップ内の特定のノードをIDで効率的に検索する再帰的探索機能を実装する",
            "dependencies": [
              "13.2"
            ],
            "details": "findNodeById関数を実装し、ルートノードから開始して全ての子ノードを再帰的に探索。深さ優先探索（DFS）アルゴリズムを使用し、見つかり次第早期リターンで効率化。ノードが見つからない場合のnull返却、循環参照対策として訪問済みノードのトラッキング、大規模マインドマップでの検索パフォーマンス最適化（インデックスキャッシュの検討）を実装。",
            "status": "pending",
            "testStrategy": "ルートノードの検索テスト、深い階層のノード検索テスト、存在しないIDの検索テスト、複数の同一IDが存在する場合の動作テスト、1000ノード以上の大規模データでの検索パフォーマンステスト"
          },
          {
            "id": 4,
            "title": "メタデータ取得機能の実装",
            "description": "マインドマップ全体やノードのメタデータを効率的に取得・集計する機能を実装する",
            "dependencies": [
              "13.3"
            ],
            "details": "マインドマップ全体の統計情報（総ノード数、最大深度、タグ一覧、ステータス別集計）を取得する機能を実装。特定ノードのメタデータ（作成日時、更新日時、優先度、進捗率等）を取得し、必要に応じて親ノードや子ノードの情報も含めた拡張メタデータを提供。メタデータのフィルタリングやソート機能も実装し、特定条件に合致するノードの一覧取得を可能にする。",
            "status": "pending",
            "testStrategy": "全体統計情報の正確性テスト、ノードメタデータの取得テスト、フィルタリング機能のテスト、空のメタデータ処理テスト、集計パフォーマンステスト"
          },
          {
            "id": 5,
            "title": "MCPツールとしての統合と公開",
            "description": "実装した機能をMCPツールとして統合し、適切なインターフェースで公開する",
            "dependencies": [
              "13.4"
            ],
            "details": "read_mindmapツールの完全な実装。zodスキーマによる入力検証（filePath必須、nodeIdオプション）、非同期ハンドラーの実装、エラーハンドリングとユーザーフレンドリーなエラーメッセージの返却、成功時のレスポンス形式の統一化。ツールの説明文書の作成、使用例の提供、MCPサーバーへの登録処理を含む。キャッシュ機能の実装により、同一ファイルへの連続アクセスを高速化。",
            "status": "pending",
            "testStrategy": "MCPツールインターフェースの動作テスト、入力検証のテスト、エラーレスポンスの形式テスト、キャッシュ機能の有効性テスト、並行リクエスト処理のテスト"
          }
        ]
      },
      {
        "id": 14,
        "title": "ノード追加機能の実装",
        "description": "マインドマップに新しいノードを追加する機能を実装する",
        "details": "1. ノード追加ロジックの実装\n2. 親ノードの検証と子ノード配列への追加\n3. ID重複チェック機能\n4. ファイル更新とバックアップ機能\n5. トランザクション的な更新の実装\n\n```typescript\nconst addNodeTool = {\n  name: 'add_node',\n  description: '新しいノードを追加',\n  inputSchema: z.object({\n    filePath: z.string(),\n    parentId: z.string(),\n    node: z.object({\n      title: z.string(),\n      description: z.string().optional(),\n      type: z.string(),\n      customAttributes: z.record(z.any()).optional()\n    })\n  }),\n  handler: async ({ filePath, parentId, node }) => {\n    const mindmap = await readMindmap(filePath);\n    const newNode = {\n      id: generateUniqueId(),\n      ...node,\n      metadata: {\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        version: 1\n      },\n      children: []\n    };\n    \n    const parent = findNodeById(mindmap.root, parentId);\n    if (!parent) throw new Error('親ノードが見つかりません');\n    \n    parent.children = parent.children || [];\n    parent.children.push(newNode);\n    \n    await saveMindmap(filePath, mindmap);\n    return { success: true, nodeId: newNode.id };\n  }\n};\n```",
        "testStrategy": "1. 正常なノード追加のテスト\n2. 無効な親ノードIDのエラーテスト\n3. ID重複検出のテスト\n4. ファイル更新の整合性テスト",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ユニークID生成機能の実装",
            "description": "ノードに割り当てるユニークなIDを生成する機能を実装し、ID重複を防ぐメカニズムを構築する",
            "dependencies": [],
            "details": "1. UUID v4またはnanoidを使用したID生成関数の実装\n2. 既存IDとの重複チェック機能の実装\n3. IDのフォーマット検証（例：'node_' プレフィックス付き）\n4. 生成されたIDのキャッシュ管理\n5. 同時実行時のID衝突防止機構",
            "status": "pending",
            "testStrategy": "1. ID生成の一意性テスト（10万回生成して重複なし）\n2. 並行処理時のID衝突テスト\n3. IDフォーマットの検証テスト\n4. パフォーマンステスト（1秒間の生成数）"
          },
          {
            "id": 2,
            "title": "ノード検索とツリー走査機能の実装",
            "description": "マインドマップ内の特定ノードを効率的に検索し、親子関係を辿る機能を実装する",
            "dependencies": [],
            "details": "1. findNodeById関数の実装（深さ優先探索）\n2. 親ノード検索機能の実装\n3. パスベースでのノード検索（例：/root/child1/child2）\n4. ノードの階層レベル取得機能\n5. 検索結果のキャッシング機構",
            "status": "pending",
            "testStrategy": "1. 深い階層構造での検索パフォーマンステスト\n2. 存在しないノードIDでのエラーハンドリングテスト\n3. 循環参照検出テスト\n4. 大規模ツリー（1000ノード以上）での検索速度テスト"
          },
          {
            "id": 3,
            "title": "ノード追加のコアロジック実装",
            "description": "新しいノードを親ノードの子要素として追加する中核機能を実装する",
            "dependencies": [
              "14.1",
              "14.2"
            ],
            "details": "1. addNodeTool のハンドラー関数実装\n2. 入力スキーマのバリデーション（zod使用）\n3. ノードのメタデータ自動生成（createdAt、updatedAt、version）\n4. 親ノードのchildren配列への安全な追加処理\n5. カスタム属性のマージ処理",
            "status": "pending",
            "testStrategy": "1. 正常系：ルートノードへの追加テスト\n2. 正常系：深い階層への追加テスト\n3. 異常系：無効な親ノードIDテスト\n4. 異常系：必須フィールド欠落テスト"
          },
          {
            "id": 4,
            "title": "ファイル操作とトランザクション管理の実装",
            "description": "マインドマップファイルの読み書きを安全に行い、エラー時のロールバック機能を実装する",
            "dependencies": [
              "14.3"
            ],
            "details": "1. readMindmap関数の実装（ファイルロック機能付き）\n2. saveMindmap関数の実装（アトミックな書き込み）\n3. トランザクションマネージャーの実装\n4. 一時ファイルを使用した安全な更新処理\n5. ファイル破損検出とリカバリー機能",
            "status": "pending",
            "testStrategy": "1. 同時書き込み時のファイルロックテスト\n2. 書き込み中断時のロールバックテスト\n3. ファイル破損時の自動リカバリーテスト\n4. 大容量ファイルの読み書きパフォーマンステスト"
          },
          {
            "id": 5,
            "title": "バックアップと変更履歴の実装",
            "description": "ノード追加時の自動バックアップと変更履歴の記録機能を実装する",
            "dependencies": [
              "14.4"
            ],
            "details": "1. ノード追加前の自動バックアップ作成\n2. 変更履歴のタイムスタンプ記録\n3. 差分データの生成と保存\n4. バックアップファイルの世代管理（最大5世代）\n5. 変更内容のサマリー生成機能",
            "status": "pending",
            "testStrategy": "1. バックアップファイルの自動生成テスト\n2. 世代管理のローテーションテスト\n3. 差分データの正確性テスト\n4. バックアップからの復元テスト"
          }
        ]
      },
      {
        "id": 15,
        "title": "ノード更新・削除機能の実装",
        "description": "既存ノードの更新と削除機能を実装する",
        "details": "1. ノード更新機能の実装（タイトル、説明、属性）\n2. ノード移動機能（親子関係の変更）\n3. ノード削除機能と子ノードの処理\n4. 削除前の確認と警告機能\n5. ルートノード保護機能\n\n```typescript\nconst updateNodeTool = {\n  name: 'update_node',\n  inputSchema: z.object({\n    filePath: z.string(),\n    nodeId: z.string(),\n    updates: z.object({\n      title: z.string().optional(),\n      description: z.string().optional(),\n      customAttributes: z.record(z.any()).optional()\n    })\n  }),\n  handler: async ({ filePath, nodeId, updates }) => {\n    const mindmap = await readMindmap(filePath);\n    const node = findNodeById(mindmap.root, nodeId);\n    \n    if (!node) throw new Error('ノードが見つかりません');\n    \n    Object.assign(node, updates);\n    node.metadata.updatedAt = new Date().toISOString();\n    node.metadata.version++;\n    \n    await saveMindmap(filePath, mindmap);\n    return { success: true };\n  }\n};\n\nconst deleteNodeTool = {\n  name: 'delete_node',\n  handler: async ({ filePath, nodeId, deleteChildren = true }) => {\n    if (nodeId === 'root') throw new Error('ルートノードは削除できません');\n    // 削除ロジック\n  }\n};\n```",
        "testStrategy": "1. ノード属性更新のテスト\n2. ノード移動の整合性テスト\n3. 子ノード含む削除のテスト\n4. ルートノード保護のテスト",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ノード更新機能の基本実装",
            "description": "既存ノードのタイトル、説明、カスタム属性を更新する基本機能を実装する",
            "dependencies": [],
            "details": "updateNodeToolの実装を完成させ、ノードIDによる検索、更新対象フィールドの部分更新、メタデータ（updatedAt、version）の自動更新機能を含める。zodスキーマによる入力検証も実装する。",
            "status": "pending",
            "testStrategy": "単体テストで正常な更新、存在しないノードIDへの更新、不正な入力値の検証、メタデータの自動更新を確認する"
          },
          {
            "id": 2,
            "title": "ノード移動機能の実装",
            "description": "マインドマップ内でノードの親子関係を変更し、階層構造を再編成する機能を実装する",
            "dependencies": [
              "15.1"
            ],
            "details": "moveNodeToolを作成し、ノードを別の親ノードに移動する機能を実装。循環参照の検出、移動先の妥当性検証、子ノードを含む移動処理、移動後のパスやレベルの再計算を含める。",
            "status": "pending",
            "testStrategy": "正常な移動、循環参照の検出、ルートノードへの移動制限、子ノードを含む移動の整合性をテストする"
          },
          {
            "id": 3,
            "title": "ノード削除機能の実装",
            "description": "ノードとその子ノードを削除する機能を実装し、削除オプションによる動作の制御を可能にする",
            "dependencies": [
              "15.1"
            ],
            "details": "deleteNodeToolの完全な実装。deleteChildrenオプションによる子ノードの処理（削除または親ノードへの昇格）、削除対象ノードの親からの参照削除、削除履歴の記録機能を含める。",
            "status": "pending",
            "testStrategy": "単一ノード削除、子ノード含む削除、子ノード昇格オプション、ルートノード削除の防止をテストする"
          },
          {
            "id": 4,
            "title": "削除確認と警告機能の実装",
            "description": "重要なノードの削除前に確認ダイアログを表示し、誤操作を防ぐ機能を実装する",
            "dependencies": [
              "15.3"
            ],
            "details": "削除前の確認プロンプト機能、影響を受ける子ノード数の表示、重要度の高いノード（多数の子ノードを持つ、特定の属性を持つ）の検出と警告、削除の取り消し可能期間の実装。",
            "status": "pending",
            "testStrategy": "確認ダイアログの表示条件、警告メッセージの内容、削除キャンセル機能、一括削除時の確認処理をテストする"
          },
          {
            "id": 5,
            "title": "ルートノード保護とエラーハンドリングの実装",
            "description": "ルートノードの保護機能と、更新・削除操作全体のエラーハンドリングを実装する",
            "dependencies": [
              "15.2",
              "15.3",
              "15.4"
            ],
            "details": "ルートノードの更新制限（特定フィールドのみ許可）、削除完全禁止、エラーメッセージの統一化、トランザクション的な操作（失敗時のロールバック）、操作ログの記録機能を実装する。",
            "status": "pending",
            "testStrategy": "ルートノード操作の制限、エラー時のロールバック、ログ記録の正確性、並行操作時の整合性をテストする"
          }
        ]
      },
      {
        "id": 16,
        "title": "検索・フィルタリング機能の実装",
        "description": "マインドマップ内の効率的な検索とフィルタリング機能を実装する",
        "details": "1. キーワード検索エンジンの実装\n2. 属性ベースのフィルタリング機能\n3. 階層レベルによる絞り込み\n4. 正規表現サポート\n5. 検索結果のランキング機能\n\n```typescript\nconst searchNodesTool = {\n  name: 'search_nodes',\n  inputSchema: z.object({\n    filePath: z.string(),\n    query: z.string().optional(),\n    filters: z.object({\n      type: z.string().optional(),\n      level: z.number().optional(),\n      attributes: z.record(z.any()).optional()\n    }).optional()\n  }),\n  handler: async ({ filePath, query, filters }) => {\n    const mindmap = await readMindmap(filePath);\n    const results = [];\n    \n    const searchRecursive = (node, level = 0) => {\n      const matches = (\n        (!query || node.title.includes(query) || node.description?.includes(query)) &&\n        (!filters?.type || node.type === filters.type) &&\n        (!filters?.level || level === filters.level)\n      );\n      \n      if (matches) {\n        results.push({ ...node, level, path: getNodePath(mindmap.root, node.id) });\n      }\n      \n      node.children?.forEach(child => searchRecursive(child, level + 1));\n    };\n    \n    searchRecursive(mindmap.root);\n    return results;\n  }\n};\n```",
        "testStrategy": "1. キーワード検索の精度テスト\n2. 複数条件フィルタリングのテスト\n3. 大規模データでのパフォーマンステスト\n4. 検索結果の妥当性検証",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "基本的なキーワード検索エンジンの実装",
            "description": "マインドマップノードのタイトルと説明文に対する基本的なキーワード検索機能を実装する",
            "dependencies": [],
            "details": "1. 検索インデックスの構築\n   - ノードのタイトルと説明文をインデックス化\n   - 日本語対応のトークナイザー実装\n   - 部分一致・完全一致の切り替え機能\n\n2. 検索アルゴリズムの実装\n   - Boyer-Moore法による高速文字列検索\n   - 大文字小文字を区別しない検索オプション\n   - ひらがな・カタカナの正規化処理\n\n3. 検索結果の構造化\n   - マッチした箇所のハイライト情報\n   - ノードまでのパス情報\n   - 検索スコアの計算",
            "status": "pending",
            "testStrategy": "1. 日本語・英語混在テキストでの検索精度テスト\n2. 大規模ノード（10,000件以上）での検索速度測定\n3. 特殊文字・記号を含む検索クエリのテスト\n4. 部分一致・完全一致の動作確認"
          },
          {
            "id": 2,
            "title": "高度な属性ベースフィルタリング機能の実装",
            "description": "ノードのメタデータや属性に基づく柔軟なフィルタリング機能を実装する",
            "dependencies": [],
            "details": "1. フィルタリングエンジンの実装\n   - 複数条件のAND/OR結合\n   - ネストされた条件の処理\n   - 動的なフィルタ生成機能\n\n2. 属性フィルタの種類\n   - priority（優先度）でのフィルタ\n   - status（ステータス）でのフィルタ\n   - assignee（担当者）でのフィルタ\n   - tags（タグ）での複数条件フィルタ\n   - progress（進捗率）での範囲フィルタ\n   - dueDate（期限）での日付範囲フィルタ\n\n3. フィルタのプリセット機能\n   - よく使うフィルタの保存\n   - フィルタのエクスポート/インポート",
            "status": "pending",
            "testStrategy": "1. 複雑な条件組み合わせでのフィルタリング精度テスト\n2. 1万件以上のノードでのフィルタリング性能測定\n3. 不正な条件入力に対するエラーハンドリングテスト\n4. フィルタプリセットの保存・読み込みテスト"
          },
          {
            "id": 3,
            "title": "階層レベルによる絞り込みと正規表現サポートの実装",
            "description": "マインドマップの階層構造を活用した絞り込み機能と、高度な正規表現検索を実装する",
            "dependencies": [
              "16.1"
            ],
            "details": "1. 階層レベル絞り込み機能\n   - 特定の深さまでのノード検索\n   - 階層範囲指定（例：レベル2-4のみ）\n   - 親子関係を考慮した検索\n   - サブツリー内検索機能\n\n2. 正規表現エンジンの統合\n   - ECMAScript正規表現のフルサポート\n   - 名前付きキャプチャグループ対応\n   - 後方参照・先読み・後読みのサポート\n   - 正規表現のバリデーション機能\n\n3. 検索モードの切り替え\n   - 通常検索/正規表現検索の切り替えUI\n   - 検索履歴の保存\n   - よく使う正規表現パターンのライブラリ",
            "status": "pending",
            "testStrategy": "1. 複雑な階層構造での絞り込み精度テスト\n2. 正規表現パターンの妥当性検証テスト\n3. 悪意のある正規表現（ReDoS）への対策テスト\n4. 検索モード切り替えの動作確認"
          },
          {
            "id": 4,
            "title": "検索結果のランキングとスコアリングシステムの実装",
            "description": "検索結果の関連性を評価し、最適な順序で表示するランキングシステムを実装する",
            "dependencies": [
              "16.1",
              "16.2",
              "16.3"
            ],
            "details": "1. スコアリングアルゴリズムの実装\n   - TF-IDF（単語頻度・逆文書頻度）の計算\n   - BM25アルゴリズムの実装\n   - ノードの重要度（階層、リンク数）の考慮\n   - メタデータの重み付け\n\n2. ランキング要素\n   - 完全一致 > 部分一致の優先度\n   - タイトル > 説明文の重み付け\n   - 最近更新されたノードの優先\n   - ユーザーの閲覧履歴の考慮\n\n3. 検索結果の最適化\n   - ページネーション機能\n   - 検索結果のグルーピング\n   - 類似ノードの提案機能",
            "status": "pending",
            "testStrategy": "1. スコアリングアルゴリズムの妥当性検証\n2. 大規模データでのランキング性能測定\n3. ユーザビリティテスト（検索結果の適切性）\n4. A/Bテストによるランキング品質の評価"
          },
          {
            "id": 5,
            "title": "統合検索インターフェースとパフォーマンス最適化の実装",
            "description": "すべての検索機能を統合した高性能な検索インターフェースを実装する",
            "dependencies": [
              "16.1",
              "16.2",
              "16.3",
              "16.4"
            ],
            "details": "1. 統合検索API の実装\n   - GraphQLによる柔軟なクエリインターフェース\n   - リアルタイム検索（インクリメンタルサーチ）\n   - 検索サジェスト機能\n   - ファセット検索の実装\n\n2. パフォーマンス最適化\n   - 検索インデックスのキャッシング\n   - 並列検索処理の実装\n   - Web Workerを使用したバックグラウンド処理\n   - 検索結果の遅延読み込み\n\n3. 高度な機能\n   - 検索結果のエクスポート機能\n   - 保存された検索条件の管理\n   - 検索アナリティクスの収集\n   - 検索APIのレート制限",
            "status": "pending",
            "testStrategy": "1. 統合APIのエンドツーエンドテスト\n2. 同時検索リクエストの負荷テスト\n3. キャッシュヒット率の測定\n4. リアルタイム検索のレスポンステスト"
          }
        ]
      },
      {
        "id": 17,
        "title": "構造分析とバリデーション機能",
        "description": "マインドマップの構造分析と整合性チェック機能を実装する",
        "details": "1. ノード統計情報の集計機能\n2. 循環参照検出アルゴリズム\n3. 孤立ノード検出機能\n4. 構造最適化の提案機能\n5. 分析レポート生成機能\n\n```typescript\nconst analyzeMindmapTool = {\n  name: 'analyze_mindmap',\n  handler: async ({ filePath }) => {\n    const mindmap = await readMindmap(filePath);\n    const stats = {\n      totalNodes: 0,\n      maxDepth: 0,\n      averageBranching: 0,\n      nodeTypes: {},\n      issues: []\n    };\n    \n    // 循環参照チェック\n    const visited = new Set();\n    const detectCycles = (node, path = []) => {\n      if (path.includes(node.id)) {\n        stats.issues.push({\n          type: 'circular_reference',\n          nodeId: node.id,\n          path: [...path, node.id]\n        });\n      }\n      visited.add(node.id);\n      node.children?.forEach(child => detectCycles(child, [...path, node.id]));\n    };\n    \n    detectCycles(mindmap.root);\n    return stats;\n  }\n};\n```",
        "testStrategy": "1. 統計情報の正確性テスト\n2. 循環参照検出のテスト\n3. 複雑な構造での分析テスト\n4. パフォーマンスベンチマーク",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ノード統計情報集計機能の実装",
            "description": "マインドマップ内の全ノードを走査し、総ノード数、最大深度、平均分岐数、ノードタイプ別統計などの基本的な統計情報を収集する機能を実装する",
            "dependencies": [],
            "details": "再帰的にノードツリーを走査し、各種統計情報を効率的に集計する。メモリ効率を考慮し、大規模なマインドマップでも高速に動作するよう実装する。統計情報には、ノード数、深度、分岐数、メタデータの利用状況（優先度、ステータス、タグの分布）などを含める",
            "status": "pending",
            "testStrategy": "様々な構造のマインドマップ（深い階層、広い階層、不均一な構造）での統計精度を検証。10,000ノード以上の大規模データでのパフォーマンステストを実施"
          },
          {
            "id": 2,
            "title": "循環参照検出アルゴリズムの実装",
            "description": "マインドマップ内のノード間で循環参照が発生していないかを検出し、問題のあるノードと循環パスを特定する機能を実装する",
            "dependencies": [
              "17.1"
            ],
            "details": "深さ優先探索（DFS）を使用して訪問済みノードを追跡し、同一パス内での重複訪問を検出。循環が検出された場合は、循環に含まれる全ノードIDとパスを記録。並列処理や非同期処理に対応し、リアルタイムでの循環参照チェックも可能にする",
            "status": "pending",
            "testStrategy": "意図的に循環参照を含むテストケースの作成。複雑な循環パターン（自己参照、相互参照、多段階循環）の検出テスト。エッジケースとして、削除されたノードへの参照も検証"
          },
          {
            "id": 3,
            "title": "孤立ノード検出機能の開発",
            "description": "ルートノードから到達できない孤立したノードや、親を持たない浮遊ノードを検出し、構造の整合性を確認する機能を実装する",
            "dependencies": [
              "17.1"
            ],
            "details": "ルートノードからの到達可能性分析を実行し、全ノードの接続状態を検証。孤立ノードが検出された場合は、その原因（削除された親ノード、不正なインポートなど）を推定。修復提案機能も含め、孤立ノードを適切な位置に再配置する候補を提示",
            "status": "pending",
            "testStrategy": "孤立ノードを含むテストデータの作成。ノード削除操作後の整合性チェック。インポート/エクスポート時の孤立ノード発生シナリオのテスト"
          },
          {
            "id": 4,
            "title": "構造最適化提案エンジンの構築",
            "description": "マインドマップの構造を分析し、可読性や管理性を向上させるための最適化提案を生成する機能を実装する",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3"
            ],
            "details": "深すぎる階層の平坦化提案、類似ノードのグループ化提案、バランスの悪い分岐の再構成提案などを生成。認知科学的な観点から、7±2の法則に基づく分岐数の最適化も提案。各提案には、実行前後の構造比較プレビューを含める",
            "status": "pending",
            "testStrategy": "様々な問題を含むマインドマップでの提案精度検証。提案実行後の構造改善度の定量的評価。ユーザビリティテストによる提案の有用性検証"
          },
          {
            "id": 5,
            "title": "分析レポート生成・出力機能の実装",
            "description": "収集した統計情報、検出した問題、最適化提案を統合し、視覚的に理解しやすい分析レポートを生成する機能を実装する",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3",
              "17.4"
            ],
            "details": "HTML/PDF/Markdownフォーマットでのレポート出力に対応。グラフやチャートを使用した視覚化（ノード分布ヒートマップ、深度分布グラフ、問題箇所のハイライト表示）を実装。レポートテンプレートのカスタマイズ機能と、定期的な自動レポート生成機能も含める",
            "status": "pending",
            "testStrategy": "各出力フォーマットの正確性検証。大規模データでのレポート生成パフォーマンステスト。視覚化要素の正確性とアクセシビリティテスト"
          }
        ]
      },
      {
        "id": 18,
        "title": "バックアップとバージョン管理システム",
        "description": "マインドマップのバックアップとバージョン管理機能を実装する",
        "details": "1. 自動バックアップ機能の実装\n2. バージョン履歴の管理\n3. 差分検出と保存\n4. ロールバック機能\n5. バックアップの圧縮と最適化\n\n```typescript\nconst backupManager = {\n  createBackup: async (filePath: string) => {\n    const timestamp = new Date().toISOString();\n    const backupPath = `${filePath}.backup.${timestamp}`;\n    const mindmap = await readMindmap(filePath);\n    \n    const backup = {\n      timestamp,\n      originalPath: filePath,\n      data: mindmap,\n      checksum: calculateChecksum(mindmap)\n    };\n    \n    await fs.writeFile(backupPath, JSON.stringify(backup));\n    return backupPath;\n  },\n  \n  restore: async (backupPath: string, targetPath: string) => {\n    const backup = JSON.parse(await fs.readFile(backupPath, 'utf-8'));\n    const currentData = await readMindmap(targetPath);\n    \n    // 現在のデータをバックアップ\n    await this.createBackup(targetPath);\n    \n    // 復元実行\n    await fs.writeFile(targetPath, JSON.stringify(backup.data));\n    return { success: true, previousBackup: backupPath };\n  }\n};\n```",
        "testStrategy": "1. バックアップ作成と復元のテスト\n2. バージョン間の差分検出テスト\n3. 破損データの検出テスト\n4. 並行アクセス時の整合性テスト",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "バックアップシステムのコア実装",
            "description": "基本的なバックアップ作成・復元機能とファイルシステム操作の実装",
            "dependencies": [],
            "details": "1. バックアップファイルの命名規則とディレクトリ構造の設計\n2. createBackup関数の実装（タイムスタンプ、チェックサム生成含む）\n3. restore関数の実装（現在データの自動バックアップ機能含む）\n4. バックアップメタデータの管理（作成日時、サイズ、チェックサム）\n5. エラーハンドリングとトランザクション処理の実装",
            "status": "pending",
            "testStrategy": "1. バックアップファイルの作成・読み取りテスト\n2. 復元処理の正確性テスト\n3. 異常系のエラーハンドリングテスト\n4. ファイルシステムの権限エラーテスト"
          },
          {
            "id": 2,
            "title": "バージョン履歴管理システムの構築",
            "description": "マインドマップの変更履歴を追跡し、バージョン間の関係を管理するシステムの実装",
            "dependencies": [
              "18.1"
            ],
            "details": "1. バージョン番号の採番ルールとブランチ管理の設計\n2. 変更履歴のデータ構造定義（作成者、変更内容、タイムスタンプ）\n3. バージョングラフの構築と親子関係の管理\n4. バージョン間のマージ・分岐機能の実装\n5. バージョン履歴のクエリAPIの開発",
            "status": "pending",
            "testStrategy": "1. バージョン番号の一意性と順序性テスト\n2. 履歴グラフの整合性テスト\n3. マージ・分岐処理の正確性テスト\n4. 大量バージョンでのパフォーマンステスト"
          },
          {
            "id": 3,
            "title": "差分検出エンジンの開発",
            "description": "マインドマップ構造の効率的な差分検出と差分データの保存機能の実装",
            "dependencies": [
              "18.1",
              "18.2"
            ],
            "details": "1. 構造化差分アルゴリズムの実装（ノードの追加・削除・変更検出）\n2. 差分データの最適化（パッチ形式での保存）\n3. 増分バックアップシステムの構築\n4. 差分の可視化とプレビュー機能\n5. 差分適用エンジンの開発",
            "status": "pending",
            "testStrategy": "1. 各種変更パターンでの差分検出精度テスト\n2. 差分サイズの最適化テスト\n3. 差分適用の可逆性テスト\n4. 複雑な構造変更での正確性テスト"
          },
          {
            "id": 4,
            "title": "ロールバック機能の実装",
            "description": "任意のバージョンへの安全なロールバック機能とコンフリクト解決機能の開発",
            "dependencies": [
              "18.2",
              "18.3"
            ],
            "details": "1. ロールバック対象バージョンの選択UI\n2. ロールバック前の状態保存と確認機能\n3. 部分的ロールバック（特定ノードのみ）の実装\n4. ロールバック時のコンフリクト検出と解決\n5. ロールバック履歴の記録と取り消し機能",
            "status": "pending",
            "testStrategy": "1. 単純なロールバックの動作テスト\n2. コンフリクト発生時の解決テスト\n3. 部分ロールバックの正確性テスト\n4. 連続ロールバックの整合性テスト"
          },
          {
            "id": 5,
            "title": "バックアップの圧縮と最適化",
            "description": "ストレージ効率を高めるための圧縮機能と古いバックアップの自動管理機能の実装",
            "dependencies": [
              "18.1",
              "18.3"
            ],
            "details": "1. 圧縮アルゴリズムの選定と実装（gzip/brotli）\n2. 重複排除システムの構築（同一ノードの共有）\n3. バックアップの自動クリーンアップポリシー\n4. アーカイブシステムの実装（古いバックアップの長期保存）\n5. ストレージ使用量の監視とアラート機能",
            "status": "pending",
            "testStrategy": "1. 圧縮率と圧縮速度のベンチマークテスト\n2. 重複排除の効果測定テスト\n3. 自動クリーンアップの動作テスト\n4. 圧縮データの復元整合性テスト"
          }
        ]
      },
      {
        "id": 19,
        "title": "セキュリティとアクセス制御の実装",
        "description": "マインドマップ操作のセキュリティ機能を実装する",
        "details": "1. パストラバーサル攻撃の防止\n2. 入力データのサニタイゼーション\n3. アクセス権限の管理\n4. 操作ログの記録\n5. 機密情報のマスキング機能\n\n```typescript\nimport path from 'path';\nimport { createHash } from 'crypto';\n\nconst securityMiddleware = {\n  validatePath: (filePath: string, basePath: string) => {\n    const resolved = path.resolve(filePath);\n    const base = path.resolve(basePath);\n    \n    if (!resolved.startsWith(base)) {\n      throw new Error('不正なファイルパスです');\n    }\n    return resolved;\n  },\n  \n  sanitizeInput: (input: any) => {\n    if (typeof input === 'string') {\n      return input.replace(/<script[^>]*>.*?<\\/script>/gi, '')\n                  .replace(/[\\x00-\\x1F\\x7F]/g, '');\n    }\n    return input;\n  },\n  \n  auditLog: async (operation: string, params: any, result: any) => {\n    const log = {\n      timestamp: new Date().toISOString(),\n      operation,\n      params: { ...params, sensitive: '[REDACTED]' },\n      result: result.success ? 'SUCCESS' : 'FAILURE',\n      hash: createHash('sha256').update(JSON.stringify(params)).digest('hex')\n    };\n    await appendToAuditLog(log);\n  }\n};\n```",
        "testStrategy": "1. パストラバーサル攻撃のテスト\n2. XSS攻撃防止のテスト\n3. 監査ログの完全性テスト\n4. アクセス制御のテスト",
        "priority": "high",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "パストラバーサル攻撃防止機能の実装",
            "description": "ファイルパスの検証とサニタイゼーション機能を実装し、ディレクトリトラバーサル攻撃を防止する",
            "dependencies": [],
            "details": "path.resolve()を使用した絶対パス変換、ベースディレクトリ外へのアクセス制御、シンボリックリンクの検証、..や./を含むパスの正規化、ホワイトリスト方式での許可パス管理を実装。セキュリティ監査ログへの記録機能も含む",
            "status": "pending",
            "testStrategy": "様々な悪意のあるパスパターン（../../../etc/passwd等）でのテスト、シンボリックリンク経由のアクセステスト、正常なパスが誤って拒否されないことの確認、境界値テスト"
          },
          {
            "id": 2,
            "title": "入力データサニタイゼーションとXSS対策",
            "description": "マインドマップデータの入力値検証とサニタイゼーション処理を実装し、XSS攻撃を防止する",
            "dependencies": [],
            "details": "HTMLエスケープ処理、スクリプトタグの除去、制御文字のフィルタリング、JSONスキーマによる型検証、DOMPurifyライブラリの統合、Content Security Policy (CSP)ヘッダーの設定、マークダウンパーサーのセキュアな設定を実装",
            "status": "pending",
            "testStrategy": "各種XSSペイロードでの侵入テスト、エスケープ処理の網羅性確認、正常なHTMLコンテンツが破壊されないことの確認、パフォーマンス影響の測定"
          },
          {
            "id": 3,
            "title": "ロールベースアクセス制御（RBAC）システムの構築",
            "description": "マインドマップの操作権限を管理するロールベースのアクセス制御システムを実装する",
            "dependencies": [
              "19.1",
              "19.2"
            ],
            "details": "ユーザーロール定義（管理者、編集者、閲覧者）、権限マトリックスの実装、JWT/セッションベース認証との統合、リソースレベルの権限制御、権限継承メカニズム、APIエンドポイントごとの権限チェックミドルウェアを実装",
            "status": "pending",
            "testStrategy": "各ロールでの操作権限テスト、権限昇格攻撃のテスト、権限継承の正確性確認、パフォーマンスへの影響測定"
          },
          {
            "id": 4,
            "title": "セキュリティ監査ログシステムの実装",
            "description": "すべてのセキュリティ関連イベントと操作を記録する包括的な監査ログシステムを構築する",
            "dependencies": [
              "19.3"
            ],
            "details": "構造化ログフォーマット（JSON）の実装、タイムスタンプとユーザー情報の記録、操作種別とパラメータの記録、ログの改ざん防止（ハッシュチェーン）、ログローテーション機能、検索可能なインデックス作成、SIEM統合のためのエクスポート機能を実装",
            "status": "pending",
            "testStrategy": "ログの完全性テスト、改ざん検出機能のテスト、ログローテーションの動作確認、大量ログ生成時のパフォーマンステスト"
          },
          {
            "id": 5,
            "title": "機密情報マスキングとデータ保護機能",
            "description": "マインドマップ内の機密情報を自動検出し、適切にマスキングする機能を実装する",
            "dependencies": [
              "19.3",
              "19.4"
            ],
            "details": "正規表現による機密情報パターン検出（クレジットカード番号、SSN、APIキー等）、可逆/不可逆マスキングオプション、ロールベースのマスキング解除権限、暗号化による保護、エクスポート時の自動マスキング、マスキングルールのカスタマイズ機能を実装",
            "status": "pending",
            "testStrategy": "各種機密情報パターンの検出精度テスト、誤検出率の測定、マスキング/アンマスキングの正確性確認、パフォーマンスへの影響測定"
          }
        ]
      },
      {
        "id": 20,
        "title": "パフォーマンス最適化とスケーラビリティ",
        "description": "大規模マインドマップに対応するパフォーマンス最適化を実装する",
        "details": "1. インメモリキャッシュの実装\n2. 遅延読み込み機能\n3. バッチ処理の最適化\n4. ストリーミング処理の実装\n5. インデックス構造の導入\n\n```typescript\nimport { LRUCache } from 'lru-cache';\n\nconst performanceOptimizer = {\n  cache: new LRUCache<string, any>({\n    max: 500,\n    ttl: 1000 * 60 * 5, // 5分\n    updateAgeOnGet: true\n  }),\n  \n  batchProcessor: {\n    queue: [],\n    process: async () => {\n      if (this.queue.length === 0) return;\n      \n      const batch = this.queue.splice(0, 100);\n      const results = await Promise.all(\n        batch.map(op => processOperation(op))\n      );\n      return results;\n    }\n  },\n  \n  streamProcessor: async function* (filePath: string) {\n    const stream = fs.createReadStream(filePath);\n    const parser = new JSONStream.parse('root.children.*');\n    \n    stream.pipe(parser);\n    \n    for await (const node of parser) {\n      yield processNode(node);\n    }\n  }\n};\n```",
        "testStrategy": "1. キャッシュヒット率の測定\n2. 大規模データでのメモリ使用量テスト\n3. バッチ処理の効率性テスト\n4. ストリーミングのスループットテスト",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "LRUキャッシュシステムの実装と最適化",
            "description": "大規模マインドマップデータの高速アクセスを実現するインメモリキャッシュシステムを実装する",
            "dependencies": [],
            "details": "LRU-Cacheライブラリを使用したキャッシュシステムの実装。キャッシュサイズ、TTL、更新戦略の最適化を行い、頻繁にアクセスされるノードデータをメモリに保持。キャッシュヒット率の監視機能とメモリ使用量の自動調整機能を含む。WeakMapを活用したメモリリークの防止と、キャッシュウォーミング戦略の実装も行う",
            "status": "pending",
            "testStrategy": "キャッシュヒット率90%以上の達成テスト、メモリ使用量の上限遵守テスト、並行アクセス時のキャッシュ整合性テスト、キャッシュエビクション戦略の効果測定"
          },
          {
            "id": 2,
            "title": "遅延読み込みとバーチャルスクロールの実装",
            "description": "大規模マインドマップの初期表示を高速化するための遅延読み込みメカニズムを構築する",
            "dependencies": [
              "20.1"
            ],
            "details": "Intersection Observer APIを使用した可視領域検出、オンデマンドでのノード展開、バーチャルスクロールによる大量ノードの効率的レンダリング。プログレッシブレンダリングによる段階的な表示と、プリフェッチ戦略による先読み機能の実装。React VirtualやTanStack Virtualなどのライブラリ活用も検討",
            "status": "pending",
            "testStrategy": "10万ノード以上のマインドマップで初期表示時間3秒以内の達成、スクロールパフォーマンス60FPS維持のテスト、メモリ使用量の線形増加防止テスト"
          },
          {
            "id": 3,
            "title": "バッチ処理とキューイングシステムの構築",
            "description": "複数の操作を効率的に処理するためのバッチ処理システムを実装する",
            "dependencies": [
              "20.1"
            ],
            "details": "操作キューの実装と自動バッチング機能の構築。優先度付きキューによる重要操作の優先実行、デバウンス・スロットリング機能の統合、エラーハンドリングとリトライメカニズムの実装。Promise.allSettledを使用した並列処理と、バックプレッシャー制御による過負荷防止機能を含む",
            "status": "pending",
            "testStrategy": "1000件/秒の操作処理能力テスト、バッチサイズの自動最適化テスト、エラー時のグレースフルデグラデーションテスト、CPU使用率80%以下の維持確認"
          },
          {
            "id": 4,
            "title": "ストリーミング処理とチャンク分割の実装",
            "description": "大規模ファイルの効率的な読み書きを実現するストリーミング処理システムを構築する",
            "dependencies": [
              "20.3"
            ],
            "details": "Node.jsのStreamAPIを使用したファイル処理、JSONStreamによる段階的パース、チャンク単位での処理とメモリ効率の最適化。Transform Streamを使用したリアルタイム変換処理、バックプレッシャー対応、プログレス通知機能の実装。Web Streams APIとの互換性確保も行う",
            "status": "pending",
            "testStrategy": "1GB以上のファイル処理でメモリ使用量100MB以下の維持、ストリーミング処理のスループット測定、チャンク境界でのデータ整合性テスト"
          },
          {
            "id": 5,
            "title": "インデックス構造とクエリ最適化の実装",
            "description": "高速検索とデータアクセスを実現するためのインデックス構造を構築する",
            "dependencies": [
              "20.2",
              "20.4"
            ],
            "details": "B-Treeベースのインデックス構造の実装、全文検索用の転置インデックス、空間インデックスによる位置ベース検索の最適化。メタデータインデックスによる属性検索の高速化、インデックスの自動更新とメンテナンス機能、クエリプランナーによる最適な検索戦略の選択機能を実装",
            "status": "pending",
            "testStrategy": "100万ノードでの検索レスポンス100ms以内の達成、インデックス更新のオーバーヘッド測定、メモリフットプリントの最適化確認、並行更新時のインデックス整合性テスト"
          }
        ]
      },
      {
        "id": 21,
        "title": "JSON/YAML相互変換機能の実装",
        "description": "ユーザーがJSON/YAMLフォーマットを選択し、ファイル読み込み時に自動変換する機能を実装する。js-yamlライブラリを使用し、変換エラーの詳細表示機能を含む。",
        "details": "1. フォーマットモード選択UIの実装\n   - ラジオボタンまたはトグルスイッチでJSON/YAMLモードを選択\n   - 選択状態をlocalStorageに保存\n   - リアルタイムプレビュー機能\n\n2. js-yamlライブラリの統合\n   ```typescript\n   import yaml from 'js-yaml';\n   import { z } from 'zod';\n\n   interface FormatConverterOptions {\n     preserveComments?: boolean;\n     indent?: number;\n     lineWidth?: number;\n   }\n\n   class FormatConverter {\n     static toYAML(data: any, options?: FormatConverterOptions): string {\n       try {\n         return yaml.dump(data, {\n           indent: options?.indent || 2,\n           lineWidth: options?.lineWidth || 80,\n           sortKeys: false,\n           noRefs: true\n         });\n       } catch (error) {\n         throw new ConversionError('YAML変換エラー', error);\n       }\n     }\n\n     static fromYAML(yamlString: string): any {\n       try {\n         return yaml.load(yamlString, {\n           schema: yaml.JSON_SCHEMA\n         });\n       } catch (error) {\n         throw new ConversionError('YAML解析エラー', error);\n       }\n     }\n\n     static validateConversion(data: any, targetFormat: 'json' | 'yaml'): ValidationResult {\n       const result = { valid: true, errors: [], warnings: [] };\n       \n       // 循環参照チェック\n       const seen = new WeakSet();\n       const checkCircular = (obj: any) => {\n         if (obj && typeof obj === 'object') {\n           if (seen.has(obj)) {\n             result.errors.push('循環参照が検出されました');\n             result.valid = false;\n             return;\n           }\n           seen.add(obj);\n           Object.values(obj).forEach(checkCircular);\n         }\n       };\n       checkCircular(data);\n\n       // YAML固有の制限チェック\n       if (targetFormat === 'yaml') {\n         // 特殊文字のチェック\n         const checkSpecialChars = (obj: any, path = '') => {\n           if (typeof obj === 'string' && /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(obj)) {\n             result.warnings.push(`制御文字が含まれています: ${path}`);\n           }\n         };\n         // 再帰的にチェック\n         JSON.stringify(data, (key, value) => {\n           checkSpecialChars(value, key);\n           return value;\n         });\n       }\n\n       return result;\n     }\n   }\n   ```\n\n3. ファイル読み込み時の自動変換機能\n   ```typescript\n   const fileLoader = {\n     async loadWithConversion(filePath: string, targetFormat: 'json' | 'yaml') {\n       const content = await fs.readFile(filePath, 'utf-8');\n       const extension = path.extname(filePath).toLowerCase();\n       let data;\n\n       // 元のフォーマットを検出\n       if (extension === '.json') {\n         data = JSON.parse(content);\n       } else if (['.yaml', '.yml'].includes(extension)) {\n         data = FormatConverter.fromYAML(content);\n       } else {\n         // 内容から推測\n         try {\n           data = JSON.parse(content);\n         } catch {\n           data = FormatConverter.fromYAML(content);\n         }\n       }\n\n       // バリデーション\n       const validation = FormatConverter.validateConversion(data, targetFormat);\n       if (!validation.valid) {\n         throw new ConversionError('変換前検証エラー', validation.errors);\n       }\n\n       // ターゲットフォーマットに変換\n       if (targetFormat === 'yaml') {\n         return {\n           data,\n           formatted: FormatConverter.toYAML(data),\n           warnings: validation.warnings\n         };\n       } else {\n         return {\n           data,\n           formatted: JSON.stringify(data, null, 2),\n           warnings: validation.warnings\n         };\n       }\n     }\n   };\n   ```\n\n4. エラーハンドリングとユーザーフィードバック\n   ```typescript\n   class ConversionError extends Error {\n     constructor(\n       message: string,\n       public details?: any,\n       public line?: number,\n       public column?: number\n     ) {\n       super(message);\n       this.name = 'ConversionError';\n     }\n\n     getDetailedMessage(): string {\n       let msg = this.message;\n       if (this.line) msg += `\\n行: ${this.line}`;\n       if (this.column) msg += `, 列: ${this.column}`;\n       if (this.details) {\n         if (this.details instanceof Error) {\n           msg += `\\n詳細: ${this.details.message}`;\n         } else {\n           msg += `\\n詳細: ${JSON.stringify(this.details, null, 2)}`;\n         }\n       }\n       return msg;\n     }\n   }\n\n   // UI通知システム\n   const notificationManager = {\n     showSuccess(message: string) {\n       toast.success(message, {\n         duration: 3000,\n         position: 'top-right'\n       });\n     },\n\n     showError(error: ConversionError) {\n       toast.error(error.getDetailedMessage(), {\n         duration: 5000,\n         position: 'top-right',\n         action: {\n           label: '詳細',\n           onClick: () => showErrorDialog(error)\n         }\n       });\n     },\n\n     showWarning(warnings: string[]) {\n       if (warnings.length > 0) {\n         toast.warning(`${warnings.length}件の警告があります`, {\n           duration: 4000,\n           description: warnings.join('\\n')\n         });\n       }\n     }\n   };\n   ```\n\n5. UIコンポーネントの実装\n   ```typescript\n   const FormatSelector: React.FC = () => {\n     const [format, setFormat] = useLocalStorage('mindmap-format', 'json');\n     const [isConverting, setIsConverting] = useState(false);\n\n     const handleFormatChange = async (newFormat: 'json' | 'yaml') => {\n       setIsConverting(true);\n       try {\n         // 現在のデータを新しいフォーマットに変換\n         const currentData = getCurrentMindmapData();\n         const result = await convertFormat(currentData, newFormat);\n         \n         // 警告を表示\n         if (result.warnings.length > 0) {\n           notificationManager.showWarning(result.warnings);\n         }\n\n         // フォーマットを更新\n         setFormat(newFormat);\n         updateEditorContent(result.formatted);\n         notificationManager.showSuccess(`${newFormat.toUpperCase()}形式に変換しました`);\n       } catch (error) {\n         notificationManager.showError(error);\n       } finally {\n         setIsConverting(false);\n       }\n     };\n\n     return (\n       <div className=\"format-selector\">\n         <label>\n           <input\n             type=\"radio\"\n             value=\"json\"\n             checked={format === 'json'}\n             onChange={() => handleFormatChange('json')}\n             disabled={isConverting}\n           />\n           JSON\n         </label>\n         <label>\n           <input\n             type=\"radio\"\n             value=\"yaml\"\n             checked={format === 'yaml'}\n             onChange={() => handleFormatChange('yaml')}\n             disabled={isConverting}\n           />\n           YAML\n         </label>\n         {isConverting && <Spinner size=\"sm\" />}\n       </div>\n     );\n   };\n   ```",
        "testStrategy": "1. フォーマット変換の正確性テスト\n   - JSON→YAML→JSONのラウンドトリップテスト\n   - 特殊文字（改行、タブ、Unicode）を含むデータの変換テスト\n   - ネストが深いオブジェクトの変換テスト\n   - 配列、null、boolean値の正確な変換\n\n2. エラーハンドリングのテスト\n   - 不正なJSON/YAMLの解析エラー表示\n   - 循環参照データの検出とエラー表示\n   - 大きすぎるファイルの変換エラー\n   - メモリ不足時の適切なエラーハンドリング\n\n3. UIインタラクションテスト\n   - フォーマット切り替え時の即座の反映\n   - localStorage への設定保存と復元\n   - 変換中のローディング表示\n   - エラー/警告通知の表示と操作\n\n4. パフォーマンステスト\n   - 1MB以上のファイルの変換速度\n   - 連続変換時のメモリリーク確認\n   - 非同期処理によるUIブロッキング回避\n\n5. 互換性テスト\n   - 様々なYAMLバージョンとの互換性\n   - エンコーディング（UTF-8、UTF-16）の処理\n   - 既存のマインドマップデータとの後方互換性",
        "status": "pending",
        "dependencies": [
          15,
          16
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "フォーマット選択UIとステート管理の実装",
            "description": "JSON/YAMLフォーマットを選択するためのUIコンポーネントを作成し、選択状態をlocalStorageで永続化する仕組みを実装する",
            "dependencies": [],
            "details": "Reactコンポーネントとしてラジオボタン形式のフォーマットセレクターを実装。useLocalStorageカスタムフックを作成して選択状態を永続化。変換中のローディング状態管理とUIの無効化処理を含む。Tailwind CSSまたはCSS Modulesでスタイリングを実装",
            "status": "pending",
            "testStrategy": "1. localStorageへの保存・読み込みの動作確認\n2. フォーマット切り替え時のUI状態変更テスト\n3. 変換中のローディング表示とボタン無効化の確認\n4. 初回アクセス時のデフォルト値（JSON）の設定確認"
          },
          {
            "id": 2,
            "title": "js-yamlライブラリの統合とFormatConverterクラスの実装",
            "description": "js-yamlライブラリをプロジェクトに統合し、JSON/YAML間の相互変換を行うFormatConverterクラスを実装する",
            "dependencies": [],
            "details": "js-yamlパッケージのインストールと型定義の追加。FormatConverterクラスにtoYAML、fromYAML、validateConversionメソッドを実装。変換オプション（インデント、行幅等）のサポート。循環参照検出と特殊文字チェック機能の実装。ConversionErrorクラスによるエラー情報の構造化",
            "status": "pending",
            "testStrategy": "1. JSON→YAML変換の正確性テスト（プリミティブ値、配列、オブジェクト）\n2. YAML→JSON変換の正確性テスト\n3. 循環参照データの検出テスト\n4. 特殊文字（制御文字、Unicode）を含むデータの変換テスト\n5. 変換オプションの動作確認"
          },
          {
            "id": 3,
            "title": "ファイル読み込みと自動変換機能の実装",
            "description": "ファイル読み込み時に拡張子を判定し、選択されたフォーマットに自動変換するfileLoaderモジュールを実装する",
            "dependencies": [
              "21.2"
            ],
            "details": "loadWithConversionメソッドの実装により、.json/.yaml/.yml拡張子の自動判定と変換を実現。拡張子が不明な場合は内容から形式を推測。変換前のバリデーション実行。変換結果にデータ、フォーマット済み文字列、警告情報を含むオブジェクトを返却",
            "status": "pending",
            "testStrategy": "1. 各拡張子（.json, .yaml, .yml）の正しい判定\n2. 拡張子なしファイルの内容推測機能のテスト\n3. 不正なファイル内容に対するエラーハンドリング\n4. 大容量ファイルの読み込みパフォーマンステスト"
          },
          {
            "id": 4,
            "title": "エラーハンドリングと通知システムの実装",
            "description": "変換エラーの詳細表示機能とユーザー向け通知システム（トースト通知）を実装する",
            "dependencies": [
              "21.2",
              "21.3"
            ],
            "details": "ConversionErrorクラスを拡張し、行番号・列番号を含む詳細なエラー情報を提供。react-hot-toastまたはreact-toastifyを使用したトースト通知の実装。成功・エラー・警告の3種類の通知タイプをサポート。エラー詳細表示用のダイアログコンポーネントの作成",
            "status": "pending",
            "testStrategy": "1. 各種エラータイプの正しい通知表示\n2. エラー位置情報（行・列）の正確な表示\n3. 複数の警告がある場合の集約表示\n4. トースト通知の自動非表示タイミングの確認"
          },
          {
            "id": 5,
            "title": "エディタ連携とリアルタイムプレビューの実装",
            "description": "フォーマット変換結果をエディタに反映し、リアルタイムでプレビューを更新する機能を実装する",
            "dependencies": [
              "21.1",
              "21.2",
              "21.3",
              "21.4"
            ],
            "details": "getCurrentMindmapData関数でエディタの現在のデータを取得。updateEditorContent関数で変換後のコンテンツをエディタに反映。フォーマット切り替え時の自動変換と即座の反映。変換処理中のエディタ無効化とプログレス表示。変換完了後のカーソル位置の保持",
            "status": "pending",
            "testStrategy": "1. フォーマット切り替え時のエディタ内容の即座の更新\n2. 変換中のエディタ無効化の動作確認\n3. カーソル位置とスクロール位置の保持\n4. 大規模データでの変換パフォーマンステスト"
          }
        ]
      },
      {
        "id": 22,
        "title": "ノード状態インジケーター表示機能の実装",
        "description": "マインドマップのノードにpriority、status等の状態情報を視覚的にインジケーターとして表示する機能を実装する。色分け、アイコン、コンパクトなビジュアル要素を使用してノードの状態を直感的に把握できるようにする。",
        "status": "in-progress",
        "dependencies": [
          15,
          16
        ],
        "priority": "high",
        "details": "1. 優先度カラーインジケーターの実装\n   ```typescript\n   interface PriorityIndicator {\n     high: { color: '#ff4444', borderWidth: 3, glowEffect: true };\n     medium: { color: '#ffaa00', borderWidth: 2, glowEffect: false };\n     low: { color: '#44aa00', borderWidth: 1, glowEffect: false };\n   }\n\n   const applyPriorityIndicator = (node: HTMLElement, priority: string) => {\n     const styles = PRIORITY_INDICATORS[priority];\n     node.style.borderColor = styles.color;\n     node.style.borderWidth = `${styles.borderWidth}px`;\n     if (styles.glowEffect) {\n       node.style.boxShadow = `0 0 8px ${styles.color}`;\n     }\n   };\n   ```\n\n2. ステータスアイコンインジケーターの実装\n   ```typescript\n   import { mdiCheckCircle, mdiClock, mdiAlert, mdiCancel } from '@mdi/js';\n\n   const STATUS_INDICATORS = {\n     completed: { icon: mdiCheckCircle, color: '#4caf50', position: 'top-right' },\n     inProgress: { icon: mdiClock, color: '#ff9800', position: 'top-right' },\n     blocked: { icon: mdiAlert, color: '#f44336', position: 'top-right' },\n     cancelled: { icon: mdiCancel, color: '#9e9e9e', position: 'top-right' }\n   };\n\n   const renderStatusIndicator = (status: string): SVGElement => {\n     const indicator = STATUS_INDICATORS[status];\n     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n     svg.setAttribute('viewBox', '0 0 24 24');\n     svg.style.fill = indicator.color;\n     svg.innerHTML = `<path d=\"${indicator.icon}\" />`;\n     return svg;\n   };\n   ```\n\n3. コンパクト状態表示バッジの実装\n   ```typescript\n   class StateIndicatorBadge {\n     private badgeElement: HTMLElement;\n\n     render(node: MindmapNode): HTMLElement {\n       this.badgeElement = document.createElement('div');\n       this.badgeElement.className = 'state-indicator-badge';\n       \n       // 優先度ドット\n       if (node.priority) {\n         const priorityDot = document.createElement('span');\n         priorityDot.className = `priority-dot priority-${node.priority}`;\n         this.badgeElement.appendChild(priorityDot);\n       }\n\n       // ステータスミニアイコン\n       if (node.status) {\n         const statusIcon = this.createMiniStatusIcon(node.status);\n         this.badgeElement.appendChild(statusIcon);\n       }\n\n       // 進捗バー（あれば）\n       if (node.progress !== undefined) {\n         const progressBar = this.createMiniProgressBar(node.progress);\n         this.badgeElement.appendChild(progressBar);\n       }\n\n       return this.badgeElement;\n     }\n   }\n   ```\n\n4. インジケーター凡例パネルの実装\n   ```typescript\n   const renderIndicatorLegend = () => {\n     const legend = document.createElement('div');\n     legend.className = 'indicator-legend';\n     legend.setAttribute('role', 'complementary');\n     legend.setAttribute('aria-label', 'インジケーター凡例');\n     \n     const sections = [\n       { \n         title: '優先度', \n         items: Object.entries(PRIORITY_INDICATORS).map(([key, value]) => ({\n           label: key,\n           visual: `<span class=\"priority-dot\" style=\"background: ${value.color}\"></span>`\n         }))\n       },\n       { \n         title: 'ステータス', \n         items: Object.entries(STATUS_INDICATORS).map(([key, value]) => ({\n           label: key,\n           visual: `<svg><path d=\"${value.icon}\" fill=\"${value.color}\"/></svg>`\n         }))\n       }\n     ];\n\n     sections.forEach(section => {\n       const group = document.createElement('div');\n       group.className = 'legend-section';\n       group.innerHTML = `<h4>${section.title}</h4>`;\n       \n       section.items.forEach(item => {\n         const row = document.createElement('div');\n         row.className = 'legend-item';\n         row.innerHTML = `${item.visual}<span>${item.label}</span>`;\n         group.appendChild(row);\n       });\n       \n       legend.appendChild(group);\n     });\n\n     return legend;\n   };\n   ```\n\n5. CSSスタイル定義\n   ```css\n   .mindmap-node {\n     position: relative;\n     transition: border-color 0.3s ease, box-shadow 0.3s ease;\n   }\n\n   .state-indicator-badge {\n     position: absolute;\n     top: -4px;\n     right: -4px;\n     display: flex;\n     gap: 4px;\n     align-items: center;\n     background: white;\n     padding: 2px 6px;\n     border-radius: 12px;\n     box-shadow: 0 1px 3px rgba(0,0,0,0.2);\n   }\n\n   .priority-dot {\n     width: 8px;\n     height: 8px;\n     border-radius: 50%;\n     display: inline-block;\n   }\n\n   .priority-dot.priority-high { background: #ff4444; }\n   .priority-dot.priority-medium { background: #ffaa00; }\n   .priority-dot.priority-low { background: #44aa00; }\n\n   .status-mini-icon {\n     width: 14px;\n     height: 14px;\n   }\n\n   .indicator-legend {\n     position: fixed;\n     bottom: 20px;\n     right: 20px;\n     background: rgba(255, 255, 255, 0.95);\n     backdrop-filter: blur(10px);\n     border-radius: 8px;\n     padding: 12px;\n     box-shadow: 0 2px 12px rgba(0,0,0,0.1);\n     max-width: 200px;\n   }\n   ```",
        "testStrategy": "1. インジケーター表示の視覚的検証\n   - 各優先度レベルのカラーインジケーターが正しく表示されることの確認\n   - ステータスアイコンの色と位置が仕様通りであることの検証\n   - バッジ内の要素配置とサイズの確認\n   - 異なるノードサイズでのインジケーターのスケーリング確認\n\n2. 状態変更の動的更新テスト\n   - priorityやstatusの変更時にインジケーターが即座に更新されることの確認\n   - 複数の状態が同時に変更された場合の表示確認\n   - アニメーション効果のスムーズさの検証\n\n3. パフォーマンステスト\n   - 100個以上のノードでインジケーターを表示した際のレンダリング速度\n   - 状態更新時の再描画効率の測定\n   - メモリ使用量の監視（DOM要素の適切な管理）\n\n4. アクセシビリティテスト\n   - インジケーターの意味がスクリーンリーダーで読み上げられることの確認\n   - 色覚多様性に配慮したインジケーターデザインの検証\n   - キーボードナビゲーションでの凡例パネルへのアクセス確認\n   - WCAG 2.1基準への準拠確認",
        "subtasks": [
          {
            "id": 1,
            "title": "優先度カラーインジケーターのReactコンポーネント実装",
            "description": "マインドマップノードの優先度（high/medium/low）を境界線の色、太さ、グロー効果で視覚的に表現するReactコンポーネントを実装する",
            "status": "done",
            "dependencies": [],
            "details": "PriorityIndicatorコンポーネントを作成し、優先度に応じたビジュアルインジケーター（色、境界線の太さ、高優先度のグロー効果）を適用する。高優先度は赤色で太い境界線とグロー効果、中優先度はオレンジ色で中程度の境界線、低優先度は緑色で細い境界線を使用。CSS-in-JSまたはCSSモジュールを使用してスタイルを管理し、ダークモード対応も考慮する",
            "testStrategy": "各優先度レベルのインジケーターが正しく適用されることを確認するユニットテスト、スナップショットテストでUIの一貫性を検証、異なるノードサイズでの表示確認、ダークモードでの視認性テスト"
          },
          {
            "id": 2,
            "title": "ステータスアイコンインジケーターのSVGレンダリングシステム実装",
            "description": "ノードのステータス（completed/inProgress/blocked/cancelled）を表すミニアイコンをSVGで動的にレンダリングし、適切な色で表示するシステムを構築する",
            "status": "done",
            "dependencies": [],
            "details": "@mdi/jsライブラリのアイコンを使用してステータスをコンパクトに視覚化。各ステータスに対応するアイコンと色のマッピングを定義し、ノードの右上にインジケーターとして配置。アイコンは14x14pxのサイズで、状態に応じた色を適用。React.memoを使用してレンダリングパフォーマンスを最適化",
            "testStrategy": "各ステータスタイプに正しいアイコンと色が表示されることの確認、アイコンの位置計算が正確であることの検証、異なるブラウザでのSVGレンダリングの互換性テスト"
          },
          {
            "id": 3,
            "title": "コンパクト状態表示バッジコンポーネントの実装",
            "description": "優先度ドット、ステータスアイコン、進捗バーなどを組み合わせたコンパクトな状態表示バッジを実装する",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "StateIndicatorBadgeコンポーネントを作成し、ノードの状態情報を最小限のスペースで表示。優先度は小さな色付きドット、ステータスはミニアイコン、進捗は細いプログレスバーで表現。白背景に薄い影を付けて視認性を確保し、ノードの右上に配置。複数の情報がある場合は横並びに表示",
            "testStrategy": "バッジ内の各要素が正しく表示されることの確認、複数の状態情報の組み合わせ表示テスト、レスポンシブ性の確認、異なるノードサイズでの適応性テスト"
          },
          {
            "id": 4,
            "title": "インジケーター凡例パネルコンポーネントの実装",
            "description": "優先度カラーとステータスアイコンの意味を説明するコンパクトな凡例パネルを作成し、表示制御機能を実装する",
            "status": "cancelled",
            "dependencies": [
              1,
              2
            ],
            "details": "画面右下に半透明の背景で固定配置される凡例パネルを実装。優先度セクションには各色ドットの意味、ステータスセクションには各アイコンの意味をコンパクトに表示。useStateで表示/非表示を管理し、localStorageに状態を保存。backdrop-filterでモダンなぼかし効果を適用",
            "testStrategy": "凡例の各項目が正しく表示されることの確認、表示/非表示の切り替え機能テスト、localStorageへの状態保存と復元のテスト、小画面でのレイアウト確認"
          },
          {
            "id": 5,
            "title": "インジケーターシステムの統合とパフォーマンス最適化",
            "description": "全てのインジケーター機能を統合し、アクセシビリティ対応とパフォーマンス最適化を実施する",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "NodeStateIndicatorコンポーネントとして全機能を統合。aria-labelでインジケーターの意味を説明し、スクリーンリーダー対応を実装。React.memoとuseMemoで不要な再レンダリングを防止。CSS containmentプロパティを使用してレイアウト計算を最適化。100ノード以上でも60fpsを維持",
            "testStrategy": "統合環境での全インジケーター機能の動作確認、WAI-ARIA準拠のアクセシビリティテスト、大規模マインドマップでのパフォーマンステスト、メモリリークの検出"
          }
        ]
      },
      {
        "id": 23,
        "title": "コアロジックの分離とプラットフォーム非依存アーキテクチャの設計",
        "description": "マインドマップのコアロジックをプラットフォーム固有の実装から分離し、Web/VSCode/CLIなど複数環境で動作可能な共通基盤を構築する。テストファースト・リファクタリング戦略により段階的に実装する。",
        "details": "1. ドメインモデルとインターフェースの定義\n   ```typescript\n   // core/domain/models.ts\n   export interface MindmapNode {\n     id: string;\n     title: string;\n     description?: string;\n     children: MindmapNode[];\n     metadata?: NodeMetadata;\n   }\n\n   export interface NodeMetadata {\n     priority?: 'high' | 'medium' | 'low';\n     status?: 'pending' | 'in-progress' | 'done';\n     tags?: string[];\n     createdAt: Date;\n     updatedAt: Date;\n   }\n\n   // core/domain/ports.ts\n   export interface FileSystemPort {\n     readFile(path: string): Promise<string>;\n     writeFile(path: string, content: string): Promise<void>;\n     exists(path: string): Promise<boolean>;\n   }\n\n   export interface RenderingPort {\n     render(mindmap: MindmapNode): void;\n     update(node: MindmapNode): void;\n   }\n   ```\n\n2. コアビジネスロジックの実装\n   ```typescript\n   // core/usecases/mindmap-service.ts\n   export class MindmapService {\n     constructor(\n       private fileSystem: FileSystemPort,\n       private parser: ParserPort,\n       private validator: ValidatorPort\n     ) {}\n\n     async loadMindmap(path: string): Promise<MindmapNode> {\n       const content = await this.fileSystem.readFile(path);\n       const parsed = await this.parser.parse(content);\n       const validated = await this.validator.validate(parsed);\n       return validated;\n     }\n\n     async saveMindmap(path: string, mindmap: MindmapNode): Promise<void> {\n       const validated = await this.validator.validate(mindmap);\n       const serialized = await this.parser.serialize(validated);\n       await this.fileSystem.writeFile(path, serialized);\n     }\n   }\n   ```\n\n3. アダプターパターンによるプラットフォーム固有実装\n   ```typescript\n   // adapters/web/file-system-adapter.ts\n   export class WebFileSystemAdapter implements FileSystemPort {\n     async readFile(path: string): Promise<string> {\n       const response = await fetch(path);\n       return response.text();\n     }\n   }\n\n   // adapters/vscode/file-system-adapter.ts\n   export class VSCodeFileSystemAdapter implements FileSystemPort {\n     constructor(private vscode: typeof import('vscode')) {}\n     \n     async readFile(path: string): Promise<string> {\n       const uri = this.vscode.Uri.file(path);\n       const data = await this.vscode.workspace.fs.readFile(uri);\n       return new TextDecoder().decode(data);\n     }\n   }\n   ```\n\n4. 依存性注入コンテナの実装\n   ```typescript\n   // core/di/container.ts\n   export class DIContainer {\n     private services = new Map<string, any>();\n     private factories = new Map<string, () => any>();\n\n     register<T>(token: string, factory: () => T): void {\n       this.factories.set(token, factory);\n     }\n\n     get<T>(token: string): T {\n       if (!this.services.has(token)) {\n         const factory = this.factories.get(token);\n         if (!factory) throw new Error(`Service ${token} not registered`);\n         this.services.set(token, factory());\n       }\n       return this.services.get(token);\n     }\n   }\n   ```\n\n5. テスト駆動開発による段階的リファクタリング\n   ```typescript\n   // tests/core/mindmap-service.test.ts\n   describe('MindmapService', () => {\n     let service: MindmapService;\n     let mockFileSystem: jest.Mocked<FileSystemPort>;\n\n     beforeEach(() => {\n       mockFileSystem = {\n         readFile: jest.fn(),\n         writeFile: jest.fn(),\n         exists: jest.fn()\n       };\n       service = new MindmapService(mockFileSystem, mockParser, mockValidator);\n     });\n\n     it('should load mindmap from file system', async () => {\n       mockFileSystem.readFile.mockResolvedValue(validJsonContent);\n       const result = await service.loadMindmap('test.json');\n       expect(result).toMatchObject(expectedMindmap);\n     });\n   });\n   ```",
        "testStrategy": "1. ユニットテストによるコアロジックの検証\n   - ドメインモデルの振る舞いテスト\n   - ビジネスロジックの単体テスト\n   - モックを使用したポート実装の独立性テスト\n   - エラーケースとエッジケースの網羅的テスト\n\n2. 統合テストによるアダプター動作の確認\n   - 各プラットフォームアダプターの実装テスト\n   - ファイルシステム操作の実環境テスト\n   - レンダリングアダプターの描画結果検証\n   - プラットフォーム間の互換性テスト\n\n3. アーキテクチャテストによる設計品質の保証\n   - 依存関係の方向性チェック（コアは外部に依存しない）\n   - レイヤー間の結合度測定\n   - インターフェース実装の完全性検証\n   - 循環依存の検出\n\n4. パフォーマンステストによる最適化効果の測定\n   - 大規模マインドマップでのメモリ使用量\n   - ファイル読み書きの速度測定\n   - プラットフォーム間のパフォーマンス比較\n   - リファクタリング前後の性能差分析",
        "status": "pending",
        "dependencies": [
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Phase1-1: MindmapCore統合テスト作成",
            "description": "現在のMindmapCoreクラスの動作を完全にカバーする統合テストを作成し、リファクタリング時の動作保証を確立する",
            "details": "現在のMindmapCoreクラス（src/core/renderer/MindmapCore.ts）の全機能に対する統合テストを作成。描画機能、ノード操作、イベント処理、レイアウト切り替えなどの動作を検証し、リファクタリング時のリグレッション防止を目的とする。",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 23
          },
          {
            "id": 2,
            "title": "Phase1-2: コアロジック振る舞いテスト作成",
            "description": "期待されるコアロジック（データ管理、ノード操作、状態管理）の振る舞いを定義するテストを作成する",
            "details": "新しく作成予定のMindmapCoreLogicクラスが満たすべき仕様をテストとして先行定義。ノードのCRUD操作、ツリー構造の操作、Undo/Redo機能、イベントシステムの動作をテストケースで明確化する。",
            "status": "done",
            "dependencies": [
              "23.1"
            ],
            "parentTaskId": 23
          },
          {
            "id": 3,
            "title": "Phase1-3: プラットフォーム統合テスト強化",
            "description": "Web環境とVSCode環境での動作差異を検証するテストを追加し、プラットフォーム固有の問題を事前に発見する",
            "details": "既存のプラットフォームアダプターのテストを強化し、ブラウザ環境とVSCode拡張環境での動作差異を検証。ファイルシステム操作、UI表示、イベント処理などの環境差異をテストでカバーする。",
            "status": "pending",
            "dependencies": [
              "23.2"
            ],
            "parentTaskId": 23
          },
          {
            "id": 4,
            "title": "Phase1-4: E2Eテスト拡充とカバレッジ確認",
            "description": "エンドツーエンドテストを拡充し、テストカバレッジを測定してテスト網羅性を確保する",
            "details": "ユーザーシナリオに基づいたE2Eテストを追加し、テストカバレッジ計測ツールでコードカバレッジを90%以上に向上。不足しているテストケースを特定し、重要な機能の動作保証を強化する。",
            "status": "pending",
            "dependencies": [
              "23.3"
            ],
            "parentTaskId": 23
          },
          {
            "id": 5,
            "title": "Phase2-1: ICoreLogicインターフェース定義",
            "description": "データ管理、ノード操作、イベントシステム、状態管理のための抽象インターフェースを設計・定義する",
            "details": "プラットフォーム非依存のコアロジック用インターフェースを定義。ICoreLogic、INodeManager、IEventSystem、IStateManagerなどの抽象化レイヤーを作成し、実装の指針を明確化する。",
            "status": "pending",
            "dependencies": [
              "23.4"
            ],
            "parentTaskId": 23
          },
          {
            "id": 6,
            "title": "Phase2-2: MindmapCoreLogicクラス新規作成",
            "description": "ICoreLogicを実装し、プラットフォーム非依存のコアロジックを集約したMindmapCoreLogicクラスを作成する",
            "details": "定義したインターフェースに基づき、真のコアロジッククラスを実装。データ構造管理、ノード操作API、イベントシステム、状態管理（Undo/Redo）を含む完全な実装を作成し、既存のテストを通過させる。",
            "status": "pending",
            "dependencies": [
              "23.5"
            ],
            "parentTaskId": 23
          },
          {
            "id": 7,
            "title": "Phase2-3: 既存コードとの段階的統合",
            "description": "テストを通過させながら、既存のMindmapCoreから新しいMindmapCoreLogicへ責務を段階的に移行する",
            "details": "現在のMindmapCoreクラスから新しいMindmapCoreLogicクラスへ、段階的に機能を移行。各ステップでテストを実行し、動作に問題がないことを確認しながらリファクタリングを進める。",
            "status": "pending",
            "dependencies": [
              "23.6"
            ],
            "parentTaskId": 23
          },
          {
            "id": 8,
            "title": "Phase2-4: MindmapCore→MindmapRenderer移行",
            "description": "最終的にMindmapCoreを描画専用のMindmapRendererクラスにリネームし、責務を明確化して統合テストで動作確認する",
            "details": "MindmapCoreクラスを描画専用のMindmapRendererクラスにリネームし、責務を明確に分離。新しいアーキテクチャでの動作をすべてのテストで確認し、リファクタリング完了を確認する。",
            "status": "pending",
            "dependencies": [
              "23.7"
            ],
            "parentTaskId": 23
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-03T03:13:21.292Z",
      "updated": "2025-08-15T01:47:45.764Z",
      "description": "Tasks for master context"
    }
  }
}